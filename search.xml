<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[zookeeper 安装]]></title>
      <url>%2F2017%2F01%2F24%2Fzookeeper-install%2F</url>
      <content type="text"><![CDATA[单机安装zookeeper1、下载响应版本的zookeeper1wget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz 2、解压安装文件12tar -xzvf zookeeper-3.4.6.tar.gzmv zookeeper-3.4.6 zookeeper 3、配置zoo.cfg123456cd zookeeper/confcp zoo_sample.cfg zoo.cfgvim zoo.cfg tickTime=2000 dataDir=/opt/server/zookeeper/data clientPort=2181 tickTime：这个时间是作为Zookeeper服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个tickTime时间就会发送一个心跳。dataDir：Zookeeper保存数据的目录，默认情况下，Zookeeper将写数据的日志文件也保存在这个目录里。clientPort：这个端口就是客户端连接Zookeeper服务器的端口，Zookeeper会监听这个端口，接受客户端的访问请求。 集群安装zookeeper1、下载响应版本的zookeeper1wget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz 2、解压安装文件12tar -xzvf zookeeper-3.4.6.tar.gzmv zookeeper-3.4.6 zookeeper 3、配置zoo.cfg1234567891011cd zookeeper/confcp zoo_sample.cfg zoo.cfgvim zoo.cfg tickTime=2000 initLimit=5 syncLimit=2 dataDir=/opt/server/zookeeper/data clientPort=2181 server.1=192.168.1.111:2888:3888 server.2=192.168.1.112:2888:3888 server.3=192.168.1.113:2888:3888 其中tickTime，dataDir，clientPort参数与单机模式一致；initLimit：这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过5个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 52000=10 秒。syncLimit：这个配置项标识Leader与Follower之间发送消息，请求和应答时间长度，最长不能超过多少个tickTime的时间长度，总的时间长度就是 22000=4 秒。server.A=B：C：D，其中：A 是一个数字，表示第几号服务器；B 该服务器IP地址；C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口D表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。 注意：如果是伪集群的配置方式，由于 B 都是一样，所以不同的Zookeeper实例通信端口号不能一样，所以要给它们分配不同的端口号。 4、在dataDir对应的目录下建立名为myid的文件，内容值为A值12vim /opt/server/zookeeper/data/myid 1 所有参与集群的主机按照上面配置，唯一不同即myid的值，与zoo.cfg中A值对应即可。注意：这里的A值与之前配置的server.x对应，各个节点对应各自的myid zookeeper配置JVM12345678910111213141516171819202122232425262728vim /opt/server/zookeeper/bin/zkServer.sh start) echo -n &quot;Starting zookeeper ... &quot; if [ -f &quot;$ZOOPIDFILE&quot; ]; then if kill -0 `cat &quot;$ZOOPIDFILE&quot;` &gt; /dev/null 2&gt;&amp;1; then echo $command already running as process `cat &quot;$ZOOPIDFILE&quot;`. exit 0 fi fi nohup &quot;$JAVA&quot; &quot;-Dzookeeper.log.dir=$&#123;ZOO_LOG_DIR&#125;&quot; &quot;-Dzookeeper.root.logger=$&#123;ZOO_LOG4J_PROP&#125;&quot; \ -cp &quot;$CLASSPATH&quot; -server -Xms128m -Xmx256m -Xmn64m -XX:PermSize=65m $ZOOMAIN &quot;$ZOOCFG&quot; &gt; &quot;$_ZOO_DAEMON_OUT&quot; 2&gt;&amp;1 &lt; /dev/null &amp; #-cp &quot;$CLASSPATH&quot; $JVMFLAGS $ZOOMAIN &quot;$ZOOCFG&quot; &gt; &quot;$_ZOO_DAEMON_OUT&quot; 2&gt;&amp;1 &lt; /dev/null &amp; #对应修改以上两行，注意这里不能在-cp之前使用注释之类的行，它对前一行一起作为命令执行 if [ $? -eq 0 ] then if /bin/echo -n $! &gt; &quot;$ZOOPIDFILE&quot; then sleep 1 echo STARTED else echo FAILED TO WRITE PID exit 1 fi else echo SERVER DID NOT START exit 1 fi ;; 启动zookeeper后可使用jmap -heap [pid]命令查看当前进程内存使用情况：1234567891011121314151617181920212223ps -ef | grep zookeeper找到对应的[pid]jmap -heap 8761 Attaching to process ID 8761, please wait... Debugger attached successfully. Server compiler detected. JVM version is 24.79-b02 using thread-local object allocation. Parallel GC with 4 thread(s) Heap Configuration: MinHeapFreeRatio = 0 MaxHeapFreeRatio = 100 MaxHeapSize = 268435456 (256.0MB) NewSize = 67108864 (64.0MB) MaxNewSize = 67108864 (64.0MB) OldSize = 5439488 (5.1875MB) NewRatio = 2 SurvivorRatio = 8 PermSize = 68157440 (65.0MB) MaxPermSize = 85983232 (82.0MB) G1HeapRegionSize = 0 (0.0MB) 启动并测试zookeeper1、启动zookeeper服务12cd /opt/server/zookeeper/bin./zkServer.sh start 2、查看zookeeper服务状态1./zkServer.sh status 3、停止zookeeper服务1./zkServer.sh stop]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mysql 其他函数]]></title>
      <url>%2F2017%2F01%2F17%2Fmysql-other-function%2F</url>
      <content type="text"><![CDATA[DEFAULT(col_name)函数使用说明：返回一个表列的默认值。若该列没有默认值则会产生错误。 FORMAT(X ,D)函数使用说明：将数字 X 的格式写为 ‘#,###,###.##’, 以四舍五入的方式保留小数点后 D 位， 并将结果以字符串的形式返回。若 D 为 0, 则返回结果不带有小数点，或不含小数部分。 GET_LOCK(str ,timeout)函数使用说明：设法使用字符串 str 给定的名字得到一个锁， 超时为 timeout 秒。若成功得到锁，则返回 1 ，若操作超时则返回 0 ( 例如 , 由于另一个客户端已提前封锁了这个名字 ), 若发生错误则返回 NULL ( 诸如缺乏记忆或线程 mysqladmin kill 被断开 ) 。假如你有一个用 GET_LOCK() 得到的锁，当你执行 RELEASE_LOCK() 或你的连接断开 ( 正常或非正常 ) 时，这个锁就会解除 INET_ATON(expr)函数使用说明：给出一个作为字符串的网络地址的点地址表示，返回一个代表该地址数值的整数。地址可以是 4 或 8 比特地址。 INET_NTOA(expr)函数使用说明：给定一个数字网络地址 (4 或 8 比特 ), 返回作为字符串的该地址的电地址表示 IS_FREE_LOCK(str)函数使用说明：检查名为 str 的锁是否可以使用 ( 换言之 , 没有被封锁 ) 。若锁可以使用，则返回 1 ( 没有人在用这个锁 ), 若这个锁正在被使用，则返回 0 ，出现错误则返回 NULL ( 诸如不正确的参数 ) 。 IS_USED_LOCK(str)函数使用说明：检查名为 str 的锁是否正在被使用 ( 换言之 , 被封锁 ) 。若被封锁，则返回使用该锁的客户端的连接标识符。否则返回 NULL 。 MASTER_POS_WAIT(log_name ,log_pos [,timeout ])函数使用说明：该函数对于控制主从同步很有用处。它会持续封锁，直到从设备阅读和应用主机记录中所有补充资料到指定的位置。返回值是其为到达指定位置而必须等待的记录事件的数目。若从设备 SQL 线程没有被启动、从设备主机信息尚未初始化、参数不正确或出现任何错误，则该函数返回 NULL 。若超时时间被超过，则返回 -1 。若在 MASTER_POS_WAIT() 等待期间，从设备 SQL 线程中止，则该函数返回 NULL 。若从设备由指定位置通过，则函数会立即返回结果。 NAME_CONST(name ,value)函数使用说明：返回给定值。 当用来产生一个结果集合列时 , NAME_CONST() 促使该列使用给定名称。 RELEASE_LOCK(str)函数使用说明：解开被 GET_LOCK() 获取的，用字符串 str 所命名的锁。若锁被解开，则返回 1 ，若改线程尚未创建锁，则返回 0 ( 此时锁没有被解开 ), 若命名的锁不存在，则返回 NULL 。若该锁从未被对 GET_LOCK() 的调用获取，或锁已经被提前解开，则该锁不存在。 SLEEP(duration)函数使用说明：睡眠 ( 暂停 ) 时间为 duration 参数给定的秒数，然后返回 0 。若 SLEEP() 被中断 , 它会返回 1 。 duration 或许或包括一个给定的以微秒为单位的分数部分。 UUID()函数使用说明：返回一个通用唯一标识符 (UUID) ， UUID 被设计成一个在时间和空间上都独一无二的数字。 2 个对 UUID() 的调用应产生 2 个不同的值，即使这些调用的执行是在两个互不相连的单独电脑上进行。 VALUES(col_name)函数使用说明：在一个 INSERT … ON DUPLICATE KEY UPDATE … 语句中，你可以在 UPDATE 子句中使用 VALUES(col_name ) 函数，用来访问来自该语句的 INSERT 部分的列值。换言之， UPDATE 子句中的 VALUES(col_name ) 访问需要被插入的 col_name 的值 , 并不会发生重复键冲突。这个函数在多行插入中特别有用。 VALUES() 函数只在 INSERT … UPDATE 语句中有意义，而在其它情况下只会返回 NULL]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mysql 聚合函数]]></title>
      <url>%2F2017%2F01%2F17%2Fmysql-aggregate-function%2F</url>
      <content type="text"><![CDATA[AVG([DISTINCT] expr)函数使用说明：返回 expr 的平均值。 DISTINCT 选项可用于返回 expr 的不同值的平均值。 BIT_AND(expr)函数使用说明：返回expr 中所有比特的 bitwise AND 。计算执行的精确度为64 比特(BIGINT) 。若找不到匹配的行，则这个函数返回18446744073709551615 。( 这是无符号 BIGINT 值，所有比特被设置为 1 ）。 BIT_OR(expr)函数使用说明：返回expr 中所有比特的bitwise OR 。计算执行的精确度为64 比特(BIGINT) 。若找不到匹配的行，则函数返回 0 。 BIT_XOR(expr)函数使用说明：返回expr 中所有比特的bitwise XOR 。计算执行的精确度为64 比特(BIGINT) 。若找不到匹配的行，则函数返回 0 。 COUNT(expr)函数使用说明：返回SELECT 语句检索到的行中非NULL 值的数目。若找不到匹配的行，则COUNT() 返回 0 COUNT(DISTINCT expr ,[expr …])函数使用说明：返回不同的非NULL 值数目。若找不到匹配的项，则COUNT(DISTINCT) 返回 0 GROUP_CONCAT(expr)函数使用说明：该函数返回带有来自一个组的连接的非NULL 值的字符串结果。其完整的语法如下所示：GROUP_CONCAT([DISTINCT] expr [,expr …] [ORDER BY {unsigned_integer | col_name | expr } [ASC | DESC] [,col_name …]] [SEPARATOR str_val ]) MIN([DISTINCT] expr), MAX([DISTINCT] expr)函数使用说明：返回 expr 的最小值和最大值。 MIN() 和 MAX() 的取值可以是一个字符串参数；在这些情况下， 它们返回最小或最大字符串值。 STD(expr) STDDEV(expr)函数使用说明：返回 expr 的总体标准偏差。这是标准 SQL 的延伸。这个函数的 STDDEV() 形式用来提供和 Oracle 的兼容性。可使用标准 SQL 函数 STDDEV_POP() 进行代替 STDDEV_POP(expr)函数使用说明：返回expr 的总体标准偏差(VAR_POP() 的平方根) 。你也可以使用 STD() 或STDDEV(), 它们具有相同的意义，然而不是标准的 SQL 。若找不到匹配的行，则STDDEV_POP() 返回 NULL STDDEV_SAMP(expr)函数使用说明：返回expr 的样本标准差 ( VAR_SAMP() 的平方根) 。若找不到匹配的行，则STDDEV_SAMP() 返回 NULL SUM([DISTINCT] expr)函数使用说明：返回expr 的总数。 若返回集合中无任何行，则 SUM() 返回NULL 。DISTINCT 关键词可用于 MySQL 5.1 中，求得expr 不同值的总和。 若找不到匹配的行，则SUM() 返回 NULL VAR_POP(expr)函数使用说明：返回 expr 总体标准方差。它将行视为总体，而不是一个样本， 所以它将行数作为分母。你也可以使用 VARIANCE(), 它具有相同的意义然而不是 标准的 SQL VAR_SAMP(expr)函数使用说明：返回expr 的样本方差。更确切的说，分母的数字是行数减去1 。若找不到匹配的行，则VAR_SAMP() 返回NULL VARIANCE(expr)函数使用说明：返回expr 的总体标准方差。这是标准SQL 的延伸。可使用标准SQL 函数 VAR_POP() 进行代替。若找不到匹配的项，则VARIANCE() 返回NULL]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mysql 信息函数]]></title>
      <url>%2F2017%2F01%2F17%2Fmysql-information-function%2F</url>
      <content type="text"><![CDATA[BENCHMARK(count ,expr)函数使用说明： BENCHMARK() 函数重复 count 次执行表达式 expr 。 它可以被用于计算 MySQL 处理表达式的速度。结果值通常为 0 。另一种用处来自 mysql 客户端内部 , 能够报告问询执行的次数 CHARSET(str)函数使用说明：返回字符串自变量的字符集。 COERCIBILITY(str)函数使用说明：返回字符串自变量的整序可压缩性值。 COLLATION(str)函数使用说明：返回字符串参数的排序方式。 CONNECTION_ID()函数使用说明：返回对于连接的连接 ID ( 线程 ID) 。每个连接都有各自的唯一 ID 。 CURRENT_USER, CURRENT_USER()函数使用说明：返回当前话路被验证的用户名和主机名组合。这个值符合确定你的存取权限的 MySQL 账户。在被指定 SQL SECURITY DEFINER 特征的存储程序内， CURRENT_USER() 返回程序的创建者 DATABASE()函数使用说明：返回使用 utf8 字符集的默认 ( 当前 ) 数据库名。在存储程序里，默认数据库是同该程序向关联的数据库，但并不一定与调用语境的默认数据库相同。 FOUND_ROWS()函数使用说明： A SELECT 语句可能包括一个 LIMIT 子句，用来限制服务器返回客户端的行数。在有些情况下，需要不用再次运行该语句而得知在没有 LIMIT 时到底该语句返回了多少行。为了知道这个行数 , 包括在 SELECT 语句中选择 SQL_CALC_FOUND_ROWS ，随后调用 FOUND_ROWS() LAST_INSERT_ID() LAST_INSERT_ID(expr)函数使用说明：自动返回最后一个 INSERT 或 UPDATE 问询为 AUTO_INCREMENT 列设置的第一个 发生的值。 ROW_COUNT()函数使用说明： ROW_COUNT() 返回被前面语句升级的、插入的或删除的行数。 这个行数和 mysql 客户端显示的行数及 mysql_affected_rows() C API 函数返回的值相同。 SCHEMA()函数使用说明：这个函数和 DATABASE() 具有相同的意义 SESSION_USER()函数使用说明： SESSION_USER() 和 USER() 具有相同的意义。 SYSTEM_USER()函数使用说明： SYSTEM_USER() 合 USER() 具有相同的意义 USER()函数使用说明：返回当前 MySQL 用户名和机主名 VERSION()函数使用说明：返回指示 MySQL 服务器版本的字符串。这个字符串使用 utf8 字符集。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mysql 加密函数]]></title>
      <url>%2F2017%2F01%2F17%2Fmysql-enctyption-function%2F</url>
      <content type="text"><![CDATA[AES_ENCRYPT(str ,key_str) , AES_DECRYPT(crypt_str ,key_str)函数使用说明：这些函数允许使用官方 AES 进行加密和数据加密 ( 高级加密标准 ) 算法 , 即以前人们所熟知的 “Rijndael” 。 保密关键字的长度为 128 比特，不过你可以通过改变源而将其延长到 256 比特。我们选择了 128 比特的原因是它的速度要快得多，且对于大多数用途而言这个保密程度已经够用。 DECODE(crypt_str ,pass_str)函数使用说明：使用 pass_str 作为密码，解密加密字符串 crypt_str ， crypt_str 应该是由 ENCODE() 返回的字符串。 ENCODE(str ,pass_str)函数使用说明：使用 pass_str 作为密码，解密 str 。 使用 DECODE() 解密结果。 DES_DECRYPT(crypt_str [,key_str ])函数使用说明：使用 DES_ENCRYPT() 加密一个字符串。若出现错误，这个函数会返回 NULL 。 DES_ENCRYPT(str [,(key_num |key_str )])函数使用说明：用 Triple-DES 算法给出的关键字加密字符串。若出现错误，这个函数会返回 NULL 。 ENCRYPT(str [,salt ])函数使用说明：使用 Unix crypt() 系统调用加密 str 。 salt 参数应为一个至少包含 2 个字符的字符串。若没有给出 salt 参数，则使用任意值。 MD5(str)函数使用说明：为字符串算出一个 MD5 128 比特检查和。该值以 32 位十六进制数字的二进制字符串的形式返回 , 若参数为 NULL 则会返回 NULL 。例如，返回值可被用作散列关键字 OLD_PASSWORD(str)函数使用说明：当 PASSWORD() 的执行变为改善安全性时， OLD_PASSWORD() 会被添加到 MySQL 。 OLD_PASSWORD() 返回从前的 PASSWORD() 执行值 ( 4.1 之前 ) ，同时允许你为任何 4.1 之前的需要连接到你的 5.1 版本 MySQL 服务器前客户端设置密码，从而不至于将它们切断 PASSWORD(str)函数使用说明：从原文密码str 计算并返回密码字符串，当参数为 NULL 时返回 NULL 。这个函数用于用户授权表的Password 列中的加密MySQL 密码存储]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mysql 全文检索函数]]></title>
      <url>%2F2017%2F01%2F17%2Fmysql-full-text-search-function%2F</url>
      <content type="text"><![CDATA[MATCH (col1,col2,…) AGAINST (expr [IN BOOLEAN MODE | WITH QUERY EXPANSION])使用Mysql全文检索fulltext的先决条件 表的类型必须是MyISAM 建立全文检索的字段类型必须是char,varchar,text 建立全文检索先期配置 ft_wordlist_charset 表示词典的字符集, 目前支持良好的有(UTF-8, gbk, gb2312, big5) ft_wordlist_file 是词表文件, 每行包括一个词及其词频(用若干制表符或空格分开,消岐专用) ft_stopword_file 表示过滤掉不索引的词表, 一行一个. ft_min_word_len 加入索引的词的最小长度, 缺省是 4, 为了支持中文单字故改为 2 建立全文检索 在建表中用FullText关键字标识字段,已存在的表用 ALTER TABLE (或 CREATE INDEX) 创建索引 CREATE fulltext INDEX index_name ON table_name(colum_name); 使用全文检索 在SELECT的WHERE字句中用MATCH函数,索引的关键词用AGAINST标识,IN BOOLEAN MODE是只有含有关键字就行,不用在乎位置,是不是起启位置. SELECT * FROM articles WHERE MATCH (tags) AGAINST (‘旅游’ IN BOOLEAN MODE);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mysql 日期函数]]></title>
      <url>%2F2017%2F01%2F17%2Fmysql-date-function%2F</url>
      <content type="text"><![CDATA[ADDDATE(date ,INTERVAL expr type) ADDDATE(expr ,days)函数使用说明： 当被第二个参数的 INTERVAL 格式激活后， ADDDATE() 就是 DATE_ADD() 的同义词。相关函数 SUBDATE() 则是 DATE_SUB() 的同义词。对于 INTERVAL 参数上的信息 ，请参见关于 DATE_ADD() 的论述。 ADDTIME(expr ,expr2)函数使用说明： ADDTIME() 将 expr2 添加至 expr 然后返回结果。 expr 是一个时间或时间日期表达式，而 expr2 是一个时间表达式。 CONVERT_TZ(dt ,from_tz ,to_tz)函数使用说明： CONVERT_TZ() 将时间日期值 dt 从 from_tz 给出的时区转到 to_tz 给出的时区，然后返回结果值。关于可能指定的时区的详细论述，若自变量无效，则这个函数会返回 NULL CURDATE()函数使用说明：将当前日期按照 ‘YYYY-MM-DD’ 或 YYYYMMDD 格式的值返回，具体格式根据函数用在字符串或是数字语境中而定 CURRENT_DATE CURRENT_DATE()函数使用说明： CURRENT_DATE 和 CURRENT_DATE() 是的同义词 CURTIME()函数使用说明： 将当前时间以 ‘HH:MM:SS’ 或 HHMMSS 的格式返回， 具体格式根据函数用在字符串或是数字语境中而定。 CURRENT_TIME, CURRENT_TIME()函数使用说明： CURRENT_TIME 和 CURRENT_TIME() 是 CURTIME() 的同义词。 CURRENT_TIMESTAMP, CURRENT_TIMESTAMP()函数使用说明： CURRENT_TIMESTAMP 和 CURRENT_TIMESTAMP() 是 NOW() 的同义词 DATE(expr)函数使用说明： 提取日期或时间日期表达式 expr 中的日期部分。 DATEDIFF(expr ,expr2)函数使用说明： DATEDIFF() 返回起始时间 expr 和结束时间 expr2 之间的天数。 Expr 和 expr2 为日期或 date-and-time 表达式。计算中只用到这些值的日期部分。 DATE_ADD(date ,INTERVAL expr type) DATE_SUB(date ,INTERVAL expr type)函数使用说明：这些函数执行日期运算。 date 是一个 DATETIME 或 DATE 值，用来指定起始时间。 expr 是一个表达式，用来指定从起始日期添加或减去的时间间隔值。 Expr 是一个字符串 ; 对于负值的时间间隔，它可以以一个 ‘-’ 开头。 type 为关键词，它指示了表达式被解释的方式。 DATE_FORMAT(date ,format)函数使用说明：根据 format 字符串安排 date 值的格式。 DAY(date)函数使用说明： DAY() 和 DAYOFMONTH() 的意义相同 DAYNAME(date)函数使用说明：返回 date 对应的工作日名称。 DAYOFMONTH(date)函数使用说明：返回 date 对应的该月日期，范围是从 1 到 31 DAYOFWEEK(date)函数使用说明：返回 date (1 = 周日 , 2 = 周一 , …, 7 = 周六 ) 对应的工作日索引。这些索引值符合 ODBC 标准 DAYOFYEAR(date)函数使用说明：返回date 对应的一年中的天数，范围是从 1 到366 。 EXTRACT(type FROM date)函数使用说明： EXTRACT() 函数所使用的时间间隔类型说明符同 DATE_ADD() 或 DATE_SUB() 的相同 , 但它从日期中提取其部分，而不是执行日期运算。 FROM_DAYS(N)函数使用说明： 给定一个天数N , 返回一个 DATE 值。 FROM_UNIXTIME(unix_timestamp )ROM_UNIXTIME(unix_timestamp ,format)函数使用说明：返回’YYYY-MM-DD HH:MM:SS’ 或YYYYMMDDHHMMSS 格式值的unix_timestamp 参数表示，具体格式取决于该函数是否用在字符串中或是数字语境中。 若format 已经给出，则结果的格式是根据format 字符串而定。 format 可以包含同DATE_FORMAT() 函数输入项列表中相同的说明符。 GET_FORMAT(DATE|TIME|DATETIME, ‘EUR’|’USA’|’JIS’|’ISO’|’INTERNAL’)函数使用说明：返回一个格式字符串。这个函数在同 DATE_FORMAT() 及 STR_TO_DATE() 函数结合时很有用 HOUR(time)函数使用说明：返回 time 对应的小时数。对于日时值的返回值范围是从 0 到 23 LAST_DAY(date)函数使用说明：获取一个日期或日期时间值，返回该月最后一天对应的值。若参数无效，则返回 NULL 。 LOCALTIME, LOCALTIME()函数使用说明： LOCALTIME 及 LOCALTIME() 和 NOW() 具有相同意义。 LOCALTIMESTAMP, LOCALTIMESTAMP()函数使用说明： LOCALTIMESTAMP 和 LOCALTIMESTAMP() 和 NOW() 具有相同意义。 MAKEDATE(year ,dayofyear)函数使用说明：给出年份值和一年中的天数值，返回一个日期。 dayofyear 必须大于 0 ，否则结果为 NULL 。 MAKETIME(hour ,minute ,second)函数使用说明： 返回由 hour 、 minute 和 second 参数计算得出的时间值 CROSECOND(expr)函数使用说明：从时间或日期时间表达式 expr 返回微秒值，其数字范围从 0 到 999999 。 MINUTE(time)函数使用说明：返回 time 对应的分钟数 , 范围是从 0 到 59 。 MONTH(date)函数使用说明：返回 date 对应的月份，范围时从 1 到 12 。 MONTHNAME(date)函数使用说明： 返回 date 对应月份的全名 NOW()函数使用说明：返回当前日期和时间值，其格式为 ‘YYYY-MM-DD HH:MM:SS’ 或 YYYYMMDDHHMMSS ， 具体格式取决于该函数是否用在字符串中或数字语境中。 PERIOD_ADD(P ,N)函数使用说明：添加 N 个月至周期 P ( 格式为 YYMM 或 YYYYMM) ，返回值的格式为 YYYYMM 。注意周期参数 P 不是 日期值。 PERIOD_DIFF(P1 ,P2)函数使用说明：返回周期 P1 和 P2 之间的月份数。 P1 和 P2 的格式应该为 YYMM 或 YYYYMM 。注意周期参数 P1 和 P2 不是 日期值。 QUARTER(date)函数使用说明：返回 date 对应的一年中的季度值，范围是从 1 到 4 SECOND(time)函数使用说明：返回 time 对应的秒数 , 范围是从 0 到 59 。 SEC_TO_TIME(seconds)函数使用说明： 返回被转化为小时、 分钟和秒数的 seconds 参数值 , 其格式为 ‘HH:MM:SS’ 或 HHMMSS ，具体格式根据该函数是否用在字符串或数字语境中而定 STR_TO_DATE(str ,format)函数使用说明：这是 DATE_FORMAT() 函数的倒转。它获取一个字符串 str 和一个格式字符串 format 。若格式字符串包含日期和时间部分，则 STR_TO_DATE() 返回一个 DATETIME 值， 若该字符串只包含日期部分或时间部分，则返回一个 DATE 或 TIME 值。 SUBDATE(date ,INTERVAL expr type) SUBDATE(expr ,days)函数使用说明：当被第二个参数的 INTERVAL 型式调用时 , SUBDATE() 和 DATE_SUB() 的意义相同。对于有关 INTERVAL 参数的信息， 见有关 DATE_ADD() 的讨论。 SUBTIME(expr ,expr2)函数使用说明： SUBTIME() 从 expr 中提取 expr2 ，然后返回结果。 expr 是一个时间或日期时间表达式，而 xpr2 是一个时间表达式。 SYSDATE()函数使用说明：返回当前日期和时间值，格式为 ‘YYYY-MM-DD HH:MM:SS’ 或 YYYYMMDDHHMMSS ， 具体格式根据函数是否用在字符串或数字语境而定。 TIME(expr)函数使用说明：提取一个时间或日期时间表达式的时间部分，并将其以字符串形式返回。 TIMEDIFF(expr ,expr2)函数使用说明： TIMEDIFF() 返回起始时间 expr 和结束时间 expr2 之间的时间。 expr 和 expr2 为时间或 date-and-time 表达式 , 两个的类型必须一样。 TIMESTAMP(expr) , TIMESTAMP(expr ,expr2)函数使用说明： 对于一个单参数 , 该函数将日期或日期时间表达式 expr 作为日期时间值返回 . 对于两个参数 , 它将时间表达式 expr2 添加到日期或日期时间表达式 expr 中，将 theresult 作为日期时间值返回。 TIMESTAMPADD(interval ,int_expr ,datetime_expr)函数使用说明：将整型表达式int_expr 添加到日期或日期时间表达式 datetime_expr 中。 int_expr 的单位被时间间隔参数给定，该参数必须是以下值的其中一个： FRAC_SECOND 、SECOND 、 MINUTE 、 HOUR 、 DAY 、 WEEK 、 MONTH 、 QUARTER 或 YEAR 。可使用所显示的关键词指定Interval 值，或使用SQLTSI 前缀。例如, DAY 或SQL_TSI_DAY 都是正确的 TIMESTAMPDIFF(interval ,datetime_expr1 ,datetime_expr2)函数使用说明：返回日期或日期时间表达式 datetime_expr1 和 datetime_expr2 the 之间的整数差。其结果的单位由 interval 参数给出。 interval 的法定值同 TIMESTAMPADD() 函数说明中所列出的相同。 TIME_FORMAT(time ,format)函数使用说明：其使用和 DATE_FORMAT() 函数相同 , 然而 format 字符串可能仅会包含处理小时、分钟和秒的格式说明符。其它说明符产生一个 NULL 值或 0 。 TIME_TO_SEC(time)函数使用说明：返回已转化为秒的 time 参数 TO_DAYS(date)函数使用说明：给定一个日期 date , 返回一个天数 ( 从年份 0 开始的天数 ) 。 UNIX_TIMESTAMP(), UNIX_TIMESTAMP(date)函数使用说明：若无参数调用，则返回一个 Unix timestamp (‘1970-01-01 00:00:00’ GMT 之后的秒数 ) 作为无符号整数。若用 date 来调用 UNIX_TIMESTAMP() ，它会将参数值以 ‘1970-01-01 00:00:00’ GMT 后的秒数的形式返回。 date 可以是一个 DATE 字符串、一个 DATETIME 字符串、一个 TIMESTAMP 或一个当地时间的 YYMMDD 或 YYYMMDD 格式的数字。 UTC_DATE, UTC_DATE()函数使用说明：返回当前 UTC 日期值，其格式为 ‘YYYY-MM-DD’ 或 YYYYMMDD ，具体格式取决于函数是否用在字符串或数字语境中。 UTC_TIME, UTC_TIME()函数使用说明：返回当前 UTC 值，其格式为 ‘HH:MM:SS’ 或 HHMMSS ，具体格式根据该函数是否用在字符串或数字语境而定。 UTC_TIMESTAMP, UTC_TIMESTAMP()函数使用说明：返回当前 UTC 日期及时间值，格式为 ‘YYYY-MM-DD HH:MM:SS’ 或 YYYYMMDDHHMMSS ，具体格式根据该函数是否用在字符串或数字语境而定 WEEK(date [,mode ])函数使用说明：该函数返回 date 对应的星期数。 WEEK() 的双参数形式允许你指定该星期是否起始于周日或周一， 以及返回值的范围是否为从 0 到 53 或从 1 到 53 。若 mode 参数被省略，则使用 default_week_format 系统自变量的值。 WEEKDAY(date)函数使用说明：返回 date (0 = 周一 , 1 = 周二 , … 6 = 周日 ) 对应的工作日索引 weekday index for WEEKOFYEAR(date)函数使用说明：将该日期的阳历周以数字形式返回，范围是从 1 到 53 。它是一个兼容度函数，相当于 WEEK(date ,3) 。 YEAR(date)函数使用说明：返回 date 对应的年份 , 范围是从 1000 到 9999 。 YEARWEEK(date), YEARWEEK(date ,start)函数使用说明：返回一个日期对应的年或周。 start 参数的工作同 start 参数对 WEEK() 的工作相同。结果中的年份可以和该年的第一周和最后一周对应的日期参数有所不同。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mysql 数学函数]]></title>
      <url>%2F2017%2F01%2F17%2Fmysql-mathematical-function%2F</url>
      <content type="text"><![CDATA[ABS(X)函数使用说明：返回 X 的绝对值 ACOS(X)函数使用说明：返回 X 反余弦 , 即 , 余弦是 X 的值。若 X 不在 -1 到 1 的范围之内，则返回 NULL 。 ASIN（X）函数使用说明：返回X 的反正弦，即，正弦为X 的值。若X 若X 不在-1 到 1 的范围之内，则返回 NULL 。 ATAN(X)函数使用说明：返回 X 的反正切，即，正切为 X 的值。 ATAN(Y ,X ) , ATAN2(Y ,X )函数使用说明：返回两个变量 X 及 Y 的反正切。 它类似于 Y 或 X 的反正切计算 , 除非两个参数的符号均用于确定结果所在象限。 CEILING(X ) CEIL(X )函数使用说明：返回不小于 X 的最小整数值。 函数COS(X)函数使用说明：返回 X 的余弦，其中 X 在弧度上已知。 COT(X)函数使用说明：返回 X 的余切 CRC32(expr)函数使用说明：计算循环冗余码校验值并返回一个 32 比特无符号值。若参数为 NULL ，则结果为 NULL 。该参数应为一个字符串，而且在不是字符串的情况下会被作为字符串处理（若有可能） DEGREES(X)函数使用说明：返回参数 X , 该参数由弧度被转化为度。 EXP(X)函数使用说明：返回 e 的 X 乘方后的值 ( 自然对数的底 ) 。 FLOOR(X)函数使用说明：返回不大于 X 的最大整数值 。 FORMAT(X ,D)函数使用说明：将数字 X 的格式写成 ‘#,###,###.##’ 格式 , 即保留小数点后 D 位，而第 D 位的保留方式为四舍五入，然后将结果以字符串的形式返回 LN(X)函数使用说明：返回 X 的自然对数 , 即 , X 相对于基数 e 的对数 LOG(X) LOG(B ,X)函数使用说明：若用一个参数调用，这个函数就会返回 X 的自然对数。 LOG2(X)函数使用说明：返回 X 的基数为 2 的对数。 LOG10(X)函数使用说明：返回 X 的基数为 10 的对数。 MOD(N ,M ) , N % M N MOD M函数使用说明： 模操作。返回 N 被 M 除后的余数。 PI()函数使用说明：返回 ϖ (pi) 的值。默认的显示小数位数是 7 位 , 然而 MySQL 内部会使用完全双精度值。 POW(X ,Y) , POWER(X ,Y)函数使用说明：返回 X 的 Y 乘方的结果值。 RADIANS(X)函数使用说明：返回由度转化为弧度的参数 X , ( 注意 ϖ 弧度等于 180 度）。 RAND() RAND(N)函数使用说明：返回一个随机浮点值 v ，范围在 0 到 1 之间 ( 即 , 其范围为 0 ≤ v ≤ 1.0) 。若已指定一个整数参数 N ，则它被用作种子值，用来产生重复序列。 ROUND(X) ROUND(X ,D)函数使用说明：返回参数 X , 其值接近于最近似的整数。在有两个参数的情况下，返回 X ，其值保留到小数点后 D 位，而第 D 位的保留方式为四舍五入。若要接保留 X 值小数点左边的 D 位，可将 D 设为负值。 SIGN(X)函数使用说明：返回参数作为 -1 、 0 或 1 的符号，该符号取决于 X 的值为负、零或正。 SIN(X)函数使用说明：返回 X 正弦，其中 X 在弧度中被给定。 SQRT(X)函数使用说明： 返回非负数 X 的二次方根。 TAN(X)函数使用说明： 返回 X 的正切，其中 X 在弧度中被给定。 TRUNCATE(X ,D)函数使用说明： 返回被舍去至小数点后 D 位的数字 X 。若 D 的值为 0, 则结果不带有小数点或不带有小数部分。可以将 D 设为负数 , 若要截去 ( 归零 ) X 小数点左起第 D 位开始后面所有低位的值]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mysql 字符串比较函数]]></title>
      <url>%2F2017%2F01%2F17%2Fmysql-string-comparison-function%2F</url>
      <content type="text"><![CDATA[ascii(str)函数用法说明：返回值为字符串 str 的最左字符的数值。假如 str 为空字符串，则返回值为 0 。假如 str 为 NULL ，则返回值为 NULL 。 ASCII() 用于带有从 0 到 255 的数值的字符 BIN(N)函数用法说明：返回值为 N 的二进制值的字符串表示，其中N 为一个 longlong (BIGINT) 数字。这等同于 CONV(N ,10,2) 。假如 N 为 NULL ，则返回值为 NULL 。 CHAR(N ,… [USING charset ])函数用法说明： CHAR() 将每个参数 N 理解为一个整数，其返回值为一个包含这些整数的代码值所给出的字符的字符串。 NULL 值被省略。 CHAR_LENGTH(str)函数使用说明：返回值为字符串 str 的长度，长度的单位为字符。一个多字节字符算作一个单字符。对于一个 包含五个二字节字符集 , LENGTH() 返回值为 10, 而 CHAR_LENGTH() 的返回值为 5 CHARACTER_LENGTH(str)函数使用说明： CHARACTER_LENGTH() 是 CHAR_LENGTH() 的同义词。 COMPRESS(string_to_compress)函数使用说明： COMPRESS( 压缩一个字符串。这个函数要求 MySQL 已经用一个诸如 zlib 的压缩库压缩过。否则，返回值始终是 NULL 。 UNCOMPRESS() 可将压缩过的字符串进行解压缩 ) 。 CONCAT(str1 ,str2 ,…)函数使用说明：返回结果为连接参数产生的字符串。如有任何一个参数为 NULL ，则返回值为 NULL 。或许有一个或多个参数。 如果所有参数均为非二进制字符串，则结果为非二进制字符串。 如果自变量中含有任一二进制字符串，则结果为一个二进制字符串。一个数字参数被转化为与之相等的二进制字符串格式；若要避免这种情况，可使用显式类型 cast, 例如： SELECT CONCAT(CAST(int_col AS CHAR), char_col) CONCAT_WS(separator ,str1 ,str2 ,…)函数使用说明： CONCAT_WS() 代表 CONCAT With Separator ，是 CONCAT() 的特殊形式。第一个参数是其它参数的分隔符。分隔符的位置放在要连接的两个字符串之间。分隔符可以是一个字符串，也可以是其它参数。如果分隔符为 NULL ，则结果为 NULL 。函数会忽略任何分隔符参数后的 NULL 值。 CONV(N from_base, to_base)函数使用说明：不同数基间转换数字。返回值为数字的 N 字符串表示，由 from_base 基转化为 to_base 基。如有任意一个参数为 NULL ，则返回值为 NULL 。自变量 N 被理解为一个整数，但是可以被指定为一个整数或字符串。最小基数为 2 ，而最大基数则为 36 。 If to_base 是一个负数，则 N 被看作一个带符号数。否则， N 被看作无符号数。 CONV() 的运行精确度为 64 比特。 ELT(N ,str1 ,str2 ,str3 ,…)函数使用说明：若 N = 1 ，则返回值为 str1 ，若 N = 2 ，则返回值为 str2 ，以此类推。若 N 小于 1 或大于参数的数目，则返回值为 NULL 。 ELT() 是 FIELD() 的补数 EXPORT_SET(bits ,on ,off [,separator [,number_of_bits ]])函数使用说明： 返回值为一个字符串，其中对于 bits 值中的每个位组，可以得到一个 on 字符串，而对于每个清零比特位，可以得到一个 off 字符串。 bits 中的比特值按照从右到左的顺序接受检验 ( 由低位比特到高位比特 ) 。字符串被分隔字符串分开 ( 默认为逗号 ‘,’) ，按照从左到右的顺序被添加到结果中。 number_of_bits 会给出被检验的二进制位数 ( 默认为 64) 。 FIELD(str, str1, str2, str3, ……)函数使用说明：返回值为 str1 , str2 , str3 ,…… 列表中的 str 指数。在找不到 str 的情况下，返回值为 0 。如果所有对于 FIELD() 的参数均为字符串，则所有参数均按照字符串进行比较。如果所有的参数均为数字，则按照数字进行比较。否则，参数按照双倍进行比较。如果 str 为 NULL ，则返回值为 0 ，原因是 NULL 不能同任何值进行同等比较。 FIELD() 是 ELT() 的补数。 FIND_IN_SET(str, strlist)函数使用说明： 假如字符串 str 在由 N 子链组成的字符串列表 strlist 中， 则返回值的范围在 1 到 N 之间 。一个字符串列表就是一个由一些被 ‘,’ 符号分开的自链组成的字符串。如果第一个参数是一个常数字符串，而第二个是 type SET 列，则 FIND_IN_SET() 函数被优化，使用比特计算。如果 str 不在 strlist 或 strlist 为空字符串，则返回值为 0 。如任意一个参数为 NULL ，则返回值为 NULL 。 这个函数在第一个参数包含一个逗号 (‘,’) 时将无法正常运行。 FORMAT(X ,D)函数使用说明： 将 number X 设置为格式 ‘#,###,###.##’, 以四舍五入的方式保留到小数点后 D 位 , 而返回结果为一个字符串。 HEX(N_or_S)函数使用说明：如果N_OR_S 是一个数字，则返回一个 十六进制值 N 的 字符串表示如果N_OR_S 是一个longlong (BIGINT) 数。这相当于 CONV(N,10,16)如果N_OR_S 是一个字符串，则返回值为一个N_OR_S 的十六进制字符串表示，其中每个N_OR_S 里的每个字符被转化为两个十六进制数字。 INSTR(str,substr)函数使用说明：返回字符串 str 中子字符串的第一个出现位置。这和LOCATE() 的双参数形式相同，除非参数的顺序被颠倒。 LCASE(str)函数使用说明：LCASE() 是 LOWER() 的同义词 LEFT(str,len)函数使用说明：返回从字符串str 开始的len 最左字符 LENGTH(str)函数使用说明： 返回值为字符串 str 的长度，单位为字节。一个多字节字符算作多字节。这意味着 对于一个包含 5 个 2 字节字符的字符串， LENGTH() 的返回值为 10, 而 CHAR_LENGTH() 的返回值则为5 。 LOAD_FILE(file_name)函数使用说明：读取文件并将这一文件按照字符串的格式返回。 文件的位置必须在服务器上 , 你必须为文件制定路径全名，而且你还必须拥有 FILE 特许权。文件必须可读取，文件容量必须小于 max_allowed_packet 字节。若文件不存在，或因不满足上述条件而不能被读取， 则函数返回值为 NULL LOCATE(substr ,str ) , LOCATE(substr ,str ,pos )函数使用说明：第一个语法返回字符串 str 中子字符串substr 的第一个出现位置。第二个语法返回字符串 str 中子字符串substr 的第一个出现位置, 起始位置在pos 。如若substr 不在str 中，则返回值为0 。 LOWER(str)函数使用说明：返回字符串 str 以及所有根据最新的字符集映射表变为小写字母的字符 LPAD(str ,len ,padstr)函数使用说明：返回字符串 str , 其左边由字符串padstr 填补到len 字符长度。假如str 的长度大于len , 则返回值被缩短至 len 字符。 LTRIM(str)函数使用说明：返回字符串 str ，其引导空格字符被删除。 MAKE_SET(bits ,str1 ,str2 ,…)数使用说明： 返回一个设定值 ( 一个包含被 ‘,’ 号分开的字字符串的字符串 ) ，由在 bits 组中具有相应的比特的字符串组成。 str1 对应比特 0, str2 对应比特 1, 以此类推。 str1 , str2 , … 中的 NULL 值不会被添加到结果中。 MID(str ,pos ,len)函数使用说明： MID(str ,pos ,len ) 是 SUBSTRING(str ,pos ,len ) 的同义词。 OCT(N)函数使用说明：返回一个 N 的八进制值的字符串表示，其中 N 是一个 longlong (BIGINT) 数。这等同于 CONV(N,10,8) 。若 N 为 NULL ，则返回值为 NULL 。 OCTET_LENGTH(str)函数使用说明： OCTET_LENGTH() 是 LENGTH() 的同义词。 函数ORD(str)函数使用说明：若字符串str 的最左字符是一个多字节字符，则返回该字符的代码， 代码的计算通过使用以下公式计算其组成字节的数值而得出:(1st byte code) + (2nd byte code × 256) + (3rd byte code × 2562) … POSITION(substr IN str)函数使用说明：POSITION(substr IN str ) 是 LOCATE(substr ,str ) 同义词 QUOTE(str)函数使用说明：引证一个字符串，由此产生一个在SQL 语句中可用作完全转义数据值的结果。 返回的字符串由单引号标注，每例都带有单引号 (‘’’) 、 反斜线符号 (‘\’) 、 ASCII NUL 以及前面有反斜线符号的Control-Z 。如果自变量的值为NULL, 则返回不带单引号的单词 “NULL” 。 REPEAT(str ,count)函数使用说明：返回一个由重复的字符串str 组成的字符串，字符串str 的数目等于count 。 若 count &lt;= 0, 则返回一个空字符串。若str 或 count 为 NULL ，则返回 NULL 。 REPLACE(str ,from_str ,to_str)函数使用说明：返回字符串str 以及所有被字符串to_str 替代的字符串from_str 。 REVERSE(str)函数使用说明：返回字符串 str ，顺序和字符顺序相反。 RIGHT(str ,len)函数使用说明：从字符串str 开始，返回最右len 字符。 RPAD(str ,len ,padstr)函数使用说明：返回字符串str , 其右边被字符串 padstr 填补至len 字符长度。假如字符串str 的长度大于 len , 则返回值被缩短到与 len 字符相同长度 RTRIM(str)函数使用说明：返回字符串 str ，结尾空格字符被删去。 SOUNDEX(str)函数使用说明：从str 返回一个soundex 字符串。 两个具有几乎同样探测的字符串应该具有同样的 soundex 字符串。一个标准的soundex 字符串的长度为4 个字符，然而SOUNDEX() 函数会返回一个人以长度的字符串。 可使用结果中的SUBSTRING() 来得到一个标准 soundex 字符串。在str 中， 会忽略所有未按照字母顺序排列的字符。所有不在A-Z 范围之内的国际字母符号被视为元音字母。 expr1 SOUNDS LIKE expr2函数使用说明： 这相当于SOUNDEX(expr1 ) = SOUNDEX(expr2 ) 。 SPACE(N)函数使用说明：返回一个由N 间隔符号组成的字符串 SUBSTRING(str ,pos) , SUBSTRING(str FROM pos) SUBSTRING(str ,pos ,len) , SUBSTRING(str FROM pos FOR len)函数使用说明：不带有len 参数的格式从字符串str 返回一个子字符串，起始于位置 pos 。带有len 参数的格式从字符串str 返回一个长度同len 字符相同的子字符串，起始于位置 pos 。 使用 FROM 的格式为标准 SQL 语法。也可能对pos 使用一个负值。假若这样，则子字符串的位置起始于字符串结尾的pos 字符，而不是字符串的开头位置。在以下格式的函数中可以对pos 使用一个负值。 SUBSTRING_INDEX(str ,delim ,count)函数使用说明：在定界符 delim 以及count 出现前，从字符串str 返回自字符串。若count 为正值, 则返回最终定界符( 从左边开始) 左边的一切内容。若count 为负值，则返回定界符（从右边开始）右边的一切内容。 TRIM([{BOTH | LEADING | TRAILING} [remstr ] FROM] str) TRIM(remstr FROM] str)函数使用说明：返回字符串 str ， 其中所有remstr 前缀和/ 或后缀都已被删除。若分类符BOTH 、LEADIN 或TRAILING 中没有一个是给定的, 则假设为BOTH 。 remstr 为可选项，在未指定情况下，可删除空格 UCASE(str)函数使用说明：UCASE() 是UPPER() 的同义词 UNCOMPRESS(string_to_uncompress)函数使用说明：对经COMPRESS() 函数压缩后的字符串进行解压缩。若参数为压缩值，则结果为 NULL 。这个函数要求 MySQL 已被诸如zlib 之类的压缩库编译过。否则, 返回值将始终是 NULL UNCOMPRESSED_LENGTH(compressed_string)函数使用说明： 返回压缩字符串压缩前的长度。 UNHEX(str)函数使用说明：执行从 HEX(str ) 的反向操作。就是说，它将参数中的每一对十六进制数字理解为一个数字，并将其转化为该数字代表的字符。结果字符以二进制字符串的形式返回 UPPER(str)函数使用说明：返回字符串 str ， 以及根据最新字符集映射转化为大写字母的字符]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mysql 控制流程函数]]></title>
      <url>%2F2017%2F01%2F17%2Fmysql-control-flow-function%2F</url>
      <content type="text"><![CDATA[CASE WHEN THEN 语法： CASE value WHEN [compare-value] THEN result [WHEN [compare-value] THEN result ……] [ELSE result ] END CASE WHEN [condition] THEN result [WHEN[condition] THEN result ……] [ELSE result] END ;函数用法说明：在第一个方案的返回结果中， value =compare-value 。而第二个方案的返回结果是第一种情况的真实结果。如果没有匹配的结果值，则返回结果为 ELSE 后的结果，如果没有 ELSE 部分，则返回值为 NULL IF 语法： IF(expr1,expr2,expr3)函数用法说明：如果 expr1 是 TRUE (expr1 &lt;&gt; 0 and expr1 &lt;&gt; NULL) ，则 IF() 的返回值为 expr2 ; 否则返回值则为 expr3 。 IF() 的返回值为数字值或字符串值，具体情况视其所在语境而定 IFNULL 语法： IFNULL(expr1,expr2)函数用法说明：假如 expr1 不为 NULL ，则 IFNULL() 的返回值为 expr1 ; 否则其返回值为 expr2 。 IFNULL() 的返回值是数字或是字符串，具体情况取决于其所使用的语境]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mysql 时间函数]]></title>
      <url>%2F2017%2F01%2F06%2Fmysql-time-function%2F</url>
      <content type="text"><![CDATA[DAYOFWEEK(date)返回日期date的星期索引(1=星期天，2=星期一, ……7=星期六)。这些索引值对应于ODBC标准。123456mysql&gt; select DAYOFWEEK(&apos;2017-01-06&apos;);+-------------------------+| DAYOFWEEK(&apos;2017-01-06&apos;) |+-------------------------+| 6 |+-------------------------+ WEEKDAY(date)返回date的星期索引(0=星期一，1=星期二, ……6= 星期天)。123456mysql&gt; select WEEKDAY(&apos;2017-01-06&apos;);+-----------------------+| WEEKDAY(&apos;2017-01-06&apos;) |+-----------------------+| 4 |+-----------------------+ DAYOFMONTH(date)返回date的月份中日期，在1到31范围内。123456mysql&gt; select DAYOFMONTH(&apos;2017-01-06&apos;);+--------------------------+| DAYOFMONTH(&apos;2017-01-06&apos;) |+--------------------------+| 6 |+--------------------------+ DAYOFYEAR(date)返回date在一年中的日数, 在1到366范围内。123456mysql&gt; select DAYOFYEAR(&apos;2016-12-31&apos;);+-------------------------+| DAYOFYEAR(&apos;2016-12-31&apos;) |+-------------------------+| 366 |+-------------------------+ MONTH(date)返回date的月份，范围1到12。123456mysql&gt; select MONTH(&apos;2017-01-06&apos;);+---------------------+| MONTH(&apos;2017-01-06&apos;) |+---------------------+| 1 |+---------------------+ DAYNAME(date)返回date的星期名字。123456mysql&gt; select DAYNAME(&quot;2017-01-06&quot;);+-----------------------+| DAYNAME(&quot;2017-01-06&quot;) |+-----------------------+| Friday |+-----------------------+ MONTHNAME(date)返回date的月份名字。123456mysql&gt; select MONTHNAME(&quot;2017-01-06&quot;);+-------------------------+| MONTHNAME(&quot;2017-01-06&quot;) |+-------------------------+| January |+-------------------------+ QUARTER(date)返回date一年中的季度，范围1到4。123456mysql&gt; select QUARTER(&apos;2016-12-31&apos;);+-----------------------+| QUARTER(&apos;2016-12-31&apos;) |+-----------------------+| 4 |+-----------------------+ WEEK(date)、WEEK(date,first)对于星期天是一周的第一天的地方，有一个单个参数，返回date的周数，范围在0到52。2个参数形式WEEK()允许你指定星期是否开始于星期天或星期一。如果第二个参数是0，星期从星期天开始，如果第二个参数是1，从星期一开始。123456789101112131415161718mysql&gt; select WEEK(&apos;2017-01-08&apos;); +--------------------+| WEEK(&apos;2017-01-08&apos;) |+--------------------+| 2 |+--------------------+mysql&gt; select WEEK(&apos;2017-01-08&apos;,0);+----------------------+| WEEK(&apos;2017-01-08&apos;,0) |+----------------------+| 2 |+----------------------+mysql&gt; select WEEK(&apos;2017-01-08&apos;,1);+----------------------+| WEEK(&apos;2017-01-08&apos;,1) |+----------------------+| 1 |+----------------------+ YEAR(date)返回date的年份，范围在1000到9999。123456mysql&gt; select YEAR(&apos;2017-01-06&apos;);+--------------------+| YEAR(&apos;2017-01-06&apos;) |+--------------------+| 2017 |+--------------------+ HOUR(time)返回time的小时，范围是0到23。123456mysql&gt; select HOUR(&apos;12:05:03&apos;);+------------------+| HOUR(&apos;12:05:03&apos;) |+------------------+| 12 |+------------------+ MINUTE(time)返回time的分钟，范围是0到59。123456mysql&gt; select MINUTE(&apos;2017-01-06 12:05:03&apos;);+-------------------------------+| MINUTE(&apos;2017-01-06 12:05:03&apos;) |+-------------------------------+| 5 |+-------------------------------+ SECOND(time)回来time的秒数，范围是0到59。123456mysql&gt; select SECOND(&apos;12:05:03&apos;);+--------------------+| SECOND(&apos;12:05:03&apos;) |+--------------------+| 3 |+--------------------+ PERIOD_ADD(P,N)增加N个月到阶段P（以格式YYMM或YYYYMM)。以格式YYYYMM返回值。注意阶段参数P不是日期值。123456mysql&gt; select PERIOD_ADD(201701,2); +----------------------+| PERIOD_ADD(201701,2) |+----------------------+| 201703 |+----------------------+ PERIOD_DIFF(P1,P2)返回在时期P1和P2之间月数，P1和P2应该以格式YYMM或YYYYMM。注意，时期参数P1和P2不是日期值。123456mysql&gt; select PERIOD_DIFF(1602,201701);+--------------------------+| PERIOD_DIFF(1602,201701) |+--------------------------+| -11 |+--------------------------+ DATE_ADD(date,INTERVAL expr type)、DATE_SUB(date,INTERVAL expr type)、ADDDATE(date,INTERVAL expr type)、SUBDATE(date,INTERVAL expr type)这些功能执行日期运算。对于MySQL 3.22，他们是新的。ADDDATE()和SUBDATE()是DATE_ADD()和DATE_SUB()的同义词。在MySQL 3.23中，你可以使用+和-而不是DATE_ADD()和DATE_SUB()。（见例子）date是一个指定开始日期的DATETIME或DATE值，expr是指定加到开始日期或从开始日期减去的间隔值一个表达式，expr是一个字符串；它可以以一个“-”开始表示负间隔。type是一个关键词，指明表达式应该如何被解释。EXTRACT(type FROM date)函数从日期中返回“type”间隔。下表显示了type和expr参数怎样被关联： type值 含义 期望的expr格式SECOND 秒 SECONDSMINUTE 分钟 MINUTESHOUR 时间 HOURSDAY 天 DAYSMONTH 月 MONTHSYEAR 年 YEARSMINUTE_SECOND 分钟和秒 “MINUTES:SECONDS”HOUR_MINUTE 小时和分钟 “HOURS:MINUTES”DAY_HOUR 天和小时 “DAYS HOURS”YEAR_MONTH 年和月 “YEARS-MONTHS”HOUR_SECOND 小时, 分钟， “HOURS:MINUTES:SECONDS”DAY_MINUTE 天, 小时, 分钟 “DAYS HOURS:MINUTES”DAY_SECOND 天, 小时, 分钟, 秒 “DAYS HOURS:MINUTES:SECONDS”MySQL在expr格式中允许任何标点分隔符。表示显示的是建议的分隔符。如果date参数是一个DATE值并且你的计算仅仅包含YEAR、MONTH和DAY部分(即，没有时间部分)，结果是一个DATE值。否则结果是一个DATETIME值。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172mysql&gt; SELECT &quot;2017-01-06 12:05:03&quot; + INTERVAL 1 SECOND; +-------------------------------------------+| &quot;2017-01-06 12:05:03&quot; + INTERVAL 1 SECOND |+-------------------------------------------+| 2017-01-06 12:05:04 |+-------------------------------------------+mysql&gt; SELECT INTERVAL 1 DAY + &quot;2017-01-06&quot;;+-------------------------------+| INTERVAL 1 DAY + &quot;2017-01-06&quot; |+-------------------------------+| 2017-01-07 |+-------------------------------+mysql&gt; SELECT &quot;2017-01-06&quot; - INTERVAL 1 SECOND; +----------------------------------+| &quot;2017-01-06&quot; - INTERVAL 1 SECOND |+----------------------------------+| 2017-01-05 23:59:59 |+----------------------------------+mysql&gt; SELECT DATE_ADD(&quot;2017-01-06 12:05:03&quot;, INTERVAL 1 SECOND); +----------------------------------------------------+| DATE_ADD(&quot;2017-01-06 12:05:03&quot;, INTERVAL 1 SECOND) |+----------------------------------------------------+| 2017-01-06 12:05:04 |+----------------------------------------------------+mysql&gt; SELECT DATE_ADD(&quot;2017-01-06 12:05:03&quot;, INTERVAL 1 DAY); +-------------------------------------------------+| DATE_ADD(&quot;2017-01-06 12:05:03&quot;, INTERVAL 1 DAY) |+-------------------------------------------------+| 2017-01-07 12:05:03 |+-------------------------------------------------+mysql&gt; SELECT DATE_ADD(&quot;2017-01-06 12:05:03&quot;, INTERVAL &quot;1:1&quot; MINUTE_SECOND); +---------------------------------------------------------------+| DATE_ADD(&quot;2017-01-06 12:05:03&quot;, INTERVAL &quot;1:1&quot; MINUTE_SECOND) |+---------------------------------------------------------------+| 2017-01-06 12:06:04 |+---------------------------------------------------------------+mysql&gt; SELECT DATE_SUB(&quot;2017-01-06 12:05:03&quot;, INTERVAL &quot;1 1:1:1&quot; DAY_SECOND); +----------------------------------------------------------------+| DATE_SUB(&quot;2017-01-06 12:05:03&quot;, INTERVAL &quot;1 1:1:1&quot; DAY_SECOND) |+----------------------------------------------------------------+| 2017-01-05 11:04:02 |+----------------------------------------------------------------+mysql&gt; SELECT DATE_ADD(&quot;2017-01-06 12:05:03&quot;, INTERVAL &quot;-1 10&quot; DAY_HOUR); +------------------------------------------------------------+| DATE_ADD(&quot;2017-01-06 12:05:03&quot;, INTERVAL &quot;-1 10&quot; DAY_HOUR) |+------------------------------------------------------------+| 2017-01-05 02:05:03 |+------------------------------------------------------------+mysql&gt; SELECT DATE_SUB(&quot;2017-01-06&quot;, INTERVAL 31 DAY); +-----------------------------------------+| DATE_SUB(&quot;2017-01-06&quot;, INTERVAL 31 DAY) |+-----------------------------------------+| 2016-12-06 |+-----------------------------------------+mysql&gt; SELECT EXTRACT(YEAR FROM &quot;2017-01-06&quot;);+---------------------------------+| EXTRACT(YEAR FROM &quot;2017-01-06&quot;) |+---------------------------------+| 2017 |+---------------------------------+mysql&gt; SELECT EXTRACT(YEAR_MONTH FROM &quot;2017-01-06 12:05:03&quot;);+------------------------------------------------+| EXTRACT(YEAR_MONTH FROM &quot;2017-01-06 12:05:03&quot;) |+------------------------------------------------+| 201701 |+------------------------------------------------+mysql&gt; SELECT EXTRACT(DAY_MINUTE FROM &quot;2017-01-06 12:05:03&quot;);+------------------------------------------------+| EXTRACT(DAY_MINUTE FROM &quot;2017-01-06 12:05:03&quot;) |+------------------------------------------------+| 61205 |+------------------------------------------------+ 如果你指定太短的间隔值(不包括type关键词期望的间隔部分)，MySQL假设你省掉了间隔值的最左面部分。例如，如果你指定一个type是DAY_SECOND，值expr被希望有天、小时、分钟和秒部分。如果你象”1:10”这样指定值，MySQL假设日子和小时部分是丢失的并且值代表分钟和秒。换句话说，”1:10” DAY_SECOND以它等价于”1:10” MINUTE_SECOND的方式解释，这对那MySQL解释TIME值表示经过的时间而非作为一天的时间的方式有二义性。如果你使用确实不正确的日期，结果是NULL。如果你增加MONTH、YEAR_MONTH或YEAR并且结果日期大于新月份的最大值天数，日子在新月用最大的天调整。123456mysql&gt; select DATE_ADD(&apos;2017-01-06&apos;, Interval 1 month); +------------------------------------------+| DATE_ADD(&apos;2017-01-06&apos;, Interval 1 month) |+------------------------------------------+| 2017-02-06 |+------------------------------------------+ 注意，从前面的例子中词INTERVAL和type关键词不是区分大小写的。 TO_DAYS(date)给出一个日期date，返回一个天数(从0年的天数)。123456789101112mysql&gt; select TO_DAYS(170106);+-----------------+| TO_DAYS(170106) |+-----------------+| 736700 |+-----------------+mysql&gt; select TO_DAYS(&apos;2017-01-06&apos;);+-----------------------+| TO_DAYS(&apos;2017-01-06&apos;) |+-----------------------+| 736700 |+-----------------------+ FROM_DAYS(N)给出一个天数N，返回一个DATE值。123456mysql&gt; select FROM_DAYS(736700);+-------------------+| FROM_DAYS(736700) |+-------------------+| 2017-01-06 |+-------------------+ DATE_FORMAT(date,format)根据format字符串格式化date值。下列修饰符可以被用在format字符串中： %M 月名字(January……December)%W 星期名字(Sunday……Saturday)%D 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。）%Y 年, 数字, 4 位%y 年, 数字, 2 位%a 缩写的星期名字(Sun……Sat)%d 月份中的天数, 数字(00……31)%e 月份中的天数, 数字(0……31)%m 月, 数字(01……12)%c 月, 数字(1……12)%b 缩写的月份名字(Jan……Dec)%j 一年中的天数(001……366)%H 小时(00……23)%k 小时(0……23)%h 小时(01……12)%I 小时(01……12)%l 小时(1……12)%i 分钟, 数字(00……59)%r 时间,12 小时(hh:mm:ss [AP]M)%T 时间,24 小时(hh:mm:ss)%S 秒(00……59)%s 秒(00……59)%p AM或PM%w 一个星期中的天数(0=Sunday ……6=Saturday ）%U 星期(0……52), 这里星期天是星期的第一天%u 星期(0……52), 这里星期一是星期的第一天%% 一个文字“%”。 所有的其他字符不做解释被复制到结果中。123456789101112131415161718192021222324mysql&gt; select DATE_FORMAT(&apos;2017-01-06 12:05:03&apos;, &apos;%W %M %Y&apos;); +------------------------------------------------+| DATE_FORMAT(&apos;2017-01-06 12:05:03&apos;, &apos;%W %M %Y&apos;) |+------------------------------------------------+| Friday January 2017 |+------------------------------------------------+mysql&gt; select DATE_FORMAT(&apos;2017-01-06 12:05:03&apos;, &apos;%H:%i:%s&apos;); +------------------------------------------------+| DATE_FORMAT(&apos;2017-01-06 12:05:03&apos;, &apos;%H:%i:%s&apos;) |+------------------------------------------------+| 12:05:03 |+------------------------------------------------+mysql&gt; select DATE_FORMAT(&apos;2017-01-06 12:05:03&apos;, &apos;%D %y %a %d %m %b %j&apos;); +------------------------------------------------------------+| DATE_FORMAT(&apos;2017-01-06 12:05:03&apos;, &apos;%D %y %a %d %m %b %j&apos;) |+------------------------------------------------------------+| 6th 17 Fri 06 01 Jan 006 |+------------------------------------------------------------+mysql&gt; select DATE_FORMAT(&apos;2017-01-06 12:05:03&apos;, &apos;%H %k %I %r %T %S %w&apos;); +------------------------------------------------------------+| DATE_FORMAT(&apos;2017-01-06 12:05:03&apos;, &apos;%H %k %I %r %T %S %w&apos;) |+------------------------------------------------------------+| 12 12 12 12:05:03 PM 12:05:03 03 5 |+------------------------------------------------------------+ TIME_FORMAT(time,format)这象上面的DATE_FORMAT()函数一样使用，但是format字符串只能包含处理小时、分钟和秒的那些格式修饰符。其他修饰符产生一个NULL值或0。 CURDATE()、CURRENT_DATE以’YYYY-MM-DD’或YYYYMMDD格式返回今天日期值，取决于函数是在一个字符串还是数字上下文被使用。123456789101112mysql&gt; select CURDATE();+------------+| CURDATE() |+------------+| 2017-01-06 |+------------+mysql&gt; select CURDATE()+2; +-------------+| CURDATE()+2 |+-------------+| 20170108 |+-------------+ CURRENT_TIME以’HH:MM:SS’或HHMMSS格式返回当前时间值，取决于函数是在一个字符串还是在数字的上下文被使用。123456mysql&gt; select CURTIME();+-----------+| CURTIME() |+-----------+| 13:55:04 |+-----------+ NOW()、SYSDATE()、CURRENT_TIMESTAMP以’YYYY-MM-DD HH:MM:SS’或YYYYMMDDHHMMSS格式返回当前的日期和时间，取决于函数是在一个字符串还是在数字的上下文被使用。123456mysql&gt; select NOW();+---------------------+| NOW() |+---------------------+| 2017-01-06 13:57:02 |+---------------------+ UNIX_TIMESTAMP()、UNIX_TIMESTAMP(date)如果没有参数调用，返回一个Unix时间戳记(从’1970-01-01 00:00:00’GMT开始的秒数)。如果UNIX_TIMESTAMP()用一个date参数被调用，它返回从’1970-01-01 00:00:00’ GMT开始的秒数值。date可以是一个DATE字符串、一个DATETIME字符串、一个TIMESTAMP或以YYMMDD或YYYYMMDD格式的本地时间的一个数字。123456789101112mysql&gt; select UNIX_TIMESTAMP();+------------------+| UNIX_TIMESTAMP() |+------------------+| 1483682742 |+------------------+mysql&gt; select UNIX_TIMESTAMP(&apos;2017-01-06 12:05:03&apos;);+---------------------------------------+| UNIX_TIMESTAMP(&apos;2017-01-06 12:05:03&apos;) |+---------------------------------------+| 1483675503 |+---------------------------------------+ 当UNIX_TIMESTAMP被用于一个TIMESTAMP列，函数将直接接受值，没有隐含的“string-to-unix-timestamp”变换。 FROM_UNIXTIME(unix_timestamp)以’YYYY-MM-DD HH:MM:SS’或YYYYMMDDHHMMSS格式返回unix_timestamp参数所表示的值，取决于函数是在一个字符串还是或数字上下文中被使用。123456mysql&gt; select FROM_UNIXTIME(1483682742);+---------------------------+| FROM_UNIXTIME(1483682742) |+---------------------------+| 2017-01-06 14:05:42 |+---------------------------+ FROM_UNIXTIME(unix_timestamp,format)返回表示 Unix 时间标记的一个字符串，根据format字符串格式化。format可以包含与DATE_FORMAT()函数列出的条目同样的修饰符。123456mysql&gt; select FROM_UNIXTIME(UNIX_TIMESTAMP(), &apos;%Y %D %M %h:%i:%s %x&apos;);+---------------------------------------------------------+| FROM_UNIXTIME(UNIX_TIMESTAMP(), &apos;%Y %D %M %h:%i:%s %x&apos;) |+---------------------------------------------------------+| 2017 6th January 02:23:08 2017 |+---------------------------------------------------------+ SEC_TO_TIME(seconds)返回seconds参数，变换成小时、分钟和秒，值以’HH:MM:SS’或HHMMSS格式化，取决于函数是在一个字符串还是在数字上下文中被使用。123456mysql&gt; select SEC_TO_TIME(2378);+-------------------+| SEC_TO_TIME(2378) |+-------------------+| 00:39:38 |+-------------------+ TIME_TO_SEC(time)返回time参数，转换成秒。123456mysql&gt; select TIME_TO_SEC(&apos;14:05:42&apos;); +-------------------------+| TIME_TO_SEC(&apos;14:05:42&apos;) |+-------------------------+| 50742 |+-------------------------+]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mysql字符函数详解]]></title>
      <url>%2F2016%2F12%2F29%2Fmysql-function%2F</url>
      <content type="text"><![CDATA[ASCII(str)返回字符串str的最左面字符的ASCII代码值。如果str是空字符串，返回0。如果str是NULL，返回NULL。 123456789101112131415161718mysql&gt; select ASCII(&apos;4&apos;);+------------+| ASCII(&apos;4&apos;) |+------------+| 52 |+------------+mysql&gt; select ASCII(4);+----------+| ASCII(4) |+----------+| 52 |+----------+mysql&gt; select ASCII(&apos;dx&apos;);+-------------+| ASCII(&apos;ex&apos;) |+-------------+| 101 |+-------------+ 也可参见ORD()函数。ORD(str) 如果字符串str最左面字符是一个多字节字符，通过以格式((first byte ASCII code)256+(second byte ASCII code))[256+third byte ASCII code…]返回字符的ASCII代码值来返回多字节字符代码。如果最左面的字符不是一个多字节字符。返回与ASCII()函数返回的相同值。123456mysql&gt; select ORD(&apos;3&apos;);+----------+| ORD(&apos;3&apos;) |+----------+| 51 |+----------+ CONV(N,from_base,to_base)在不同的数字基之间变换数字。返回数字N的字符串数字，从from_base基变换为to_base基，如果任何参数是NULL，返回NULL。参数N解释为一个整数，但是可以指定为一个整数或一个字符串。最小基是2且最大的基是36。如果to_base是一个负数，N被认为是一个有符号数，否则，N被当作无符号数。 CONV以64位点精度工作。123456789101112131415161718192021222324mysql&gt; select CONV(&quot;A&quot;,16,2);+----------------+| CONV(&quot;A&quot;,16,2) |+----------------+| 1010 |+----------------+mysql&gt; select CONV(&quot;6EB&quot;,18,8);+------------------+| CONV(&quot;6EB&quot;,18,8) |+------------------+| 4237 |+------------------+mysql&gt; select CONV(-178,10,-18);+-------------------+| CONV(-178,10,-18) |+-------------------+| -9G |+-------------------+mysql&gt; select CONV(10+&quot;10&quot;+&apos;10&apos;+0xB,10,10);+------------------------------+| CONV(10+&quot;10&quot;+&apos;10&apos;+0xB,10,10) |+------------------------------+| 41 |+------------------------------+ BIN(N) 返回二进制值N的一个字符串表示，在此N是一个长整数(BIGINT)数字，这等价于CONV(N,10,2)。如果N是NULL，返回NULL。123456mysql&gt; select BIN(532);+------------+| BIN(532) |+------------+| 1000010100 |+------------+ OCT(N)返回八进制值N的一个字符串的表示，在此N是一个长整型数字，这等价于CONV(N,10,8)。如果N是NULL，返回NULL。123456mysql&gt; select OCT(98);+---------+| OCT(98) |+---------+| 142 |+---------+ HEX(N)返回十六进制值N一个字符串的表示，在此N是一个长整型(BIGINT)数字，这等价于CONV(N,10,16)。如果N是NULL，返回NULL。123456mysql&gt; select HEX(432);+----------+| HEX(432) |+----------+| 1B0 |+----------+ CHAR(N,…)CHAR()将参数解释为整数并且返回由这些整数的ASCII代码字符组成的一个字符串。NULL值被跳过。123456789101112mysql&gt; select CHAR(77, 121, 83, 81,&apos;76&apos;);+----------------------------+| CHAR(77, 121, 83, 81,&apos;76&apos;) |+----------------------------+| MySQL |+----------------------------+mysql&gt; select CHAR(77,77.3,&apos;77.3&apos;);+----------------------+| CHAR(77,77.3,&apos;77.3&apos;) |+----------------------+| MMM |+----------------------+ CONCAT(str1,str2,…)返回来自于参数连结的字符串。如果任何参数是NULL，返回NULL。可以有超过2个的参数。一个数字参数被变换为等价的字符串形式。123456789101112131415161718mysql&gt; select CONCAT(&apos;My&apos;, &apos;S&apos;, &apos;QL&apos;);+-------------------------+| CONCAT(&apos;My&apos;, &apos;S&apos;, &apos;QL&apos;) |+-------------------------+| MySQL |+-------------------------+mysql&gt; select CONCAT(&apos;My&apos;, NULL, &apos;QL&apos;);+--------------------------+| CONCAT(&apos;My&apos;, NULL, &apos;QL&apos;) |+--------------------------+| NULL |+--------------------------+mysql&gt; select CONCAT(14.3);+--------------+| CONCAT(14.3) |+--------------+| 14.3 |+--------------+ LENGTH(str)、OCTET_LENGTH(str)、CHAR_LENGTH(str)、CHARACTER_LENGTH(str)返回字符串str的长度。12345678910111213mysql&gt; select LENGTH(&apos;hello world&apos;);+-----------------------+| LENGTH(&apos;hello world&apos;) |+-----------------------+| 11 |+-----------------------+mysql&gt; select OCTET_LENGTH(&apos;hello world&apos;);+-----------------------------+| OCTET_LENGTH(&apos;hello world&apos;) |+-----------------------------+| 11 |+-----------------------------+注意，对于多字节字符，其CHAR_LENGTH()仅计算一次。 LOCATE(substr,str,pos)、POSITION(substr IN str)返回子串substr在字符串str第一个出现的位置，如果substr不是在str里面，返回0如果设置了pos值，那么起始位置将从pos处，否则从1开始。12345678910111213mysql&gt; select LOCATE(&apos;bar&apos;, &apos;foobarbar&apos;);+----------------------------+| LOCATE(&apos;bar&apos;, &apos;foobarbar&apos;) |+----------------------------+| 4 |+----------------------------+mysql&gt; select LOCATE(&apos;bar&apos;, &apos;foobarbar&apos;, 5);+-------------------------------+| LOCATE(&apos;bar&apos;, &apos;foobarbar&apos;, 5) |+-------------------------------+| 7 |+-------------------------------+这函数是多字节可靠的。 INSTR(str,substr)返回子串substr在字符串str中的第一个出现的位置。这与有2个参数形式的LOCATE()相同，除了参数被颠倒。1234567mysql&gt; select INSTR(&apos;foobarbar&apos;, &apos;bar&apos;);+---------------------------+| INSTR(&apos;foobarbar&apos;, &apos;bar&apos;) |+---------------------------+| 4 |+---------------------------+这函数是多字节可靠的。 LPAD(str,len,padstr)返回字符串str，左面用字符串padstr填补直到str是len个字符长。123456mysql&gt; select LPAD(&apos;A&apos;,5,&apos;BCD&apos;);+-------------------+| LPAD(&apos;A&apos;,5,&apos;BCD&apos;) |+-------------------+| BCDBA |+-------------------+ RPAD(str,len,padstr)返回字符串str，右面用字符串padstr填补直到str是len个字符长。123456mysql&gt; select RPAD(&apos;A&apos;,5,&apos;BCD&apos;);+-------------------+| RPAD(&apos;A&apos;,5,&apos;BCD&apos;) |+-------------------+| ABCDB |+-------------------+ LEFT(str,len)返回字符串str的最左面len个字符。1234567mysql&gt; select LEFT(&apos;hello world&apos;, 7);+------------------------+| LEFT(&apos;hello world&apos;, 7) |+------------------------+| hello w |+------------------------+该函数是多字节可靠的。 RIGHT(str,len)返回字符串str的最右面len个字符。1234567mysql&gt; select RIGHT(&apos;hello world&apos;, 7); +-------------------------+| RIGHT(&apos;hello world&apos;, 7) |+-------------------------+| o world |+-------------------------+该函数是多字节可靠的。 SUBSTRING(str,pos,len)、SUBSTRING(str FROM pos FOR len)、MID(str,pos,len)从字符串str返回一个len个字符的子串，从位置pos开始。使用FROM的变种形式是ANSI SQL92语法。1234567mysql&gt; select SUBSTRING(&apos;abcdefghijk&apos;,5,6); +------------------------------+| SUBSTRING(&apos;abcdefghijk&apos;,5,6) |+------------------------------+| efghij |+------------------------------+该函数是多字节可靠的。 SUBSTRING(str,pos)、SUBSTRING(str FROM pos)从字符串str的起始位置pos返回一个子串。1234567mysql&gt; select SUBSTRING(&apos;abcdefghijk&apos;,5); +----------------------------+| SUBSTRING(&apos;abcdefghijk&apos;,5) |+----------------------------+| efghijk |+----------------------------+该函数是多字节可靠的。 SUBSTRING_INDEX(str,delim,count)返回从字符串str的第count个出现的分隔符delim之后的子串。如果count是正数，返回最后的分隔符到左边(从左边数) 的所有字符。如果count是负数，返回最后的分隔符到右边的所有字符(从右边数)。1234567mysql&gt; select SUBSTRING_INDEX(&apos;http://blog.imarkofu.com&apos;, &apos;.&apos;, 2); +-----------------------------------------------------+| SUBSTRING_INDEX(&apos;http://blog.imarkofu.com&apos;, &apos;.&apos;, 2) |+-----------------------------------------------------+| http://blog.imarkofu |+-----------------------------------------------------+该函数对多字节是可靠的。 LTRIM(str)返回删除了其前置空格字符的字符串str。123456mysql&gt; select LTRIM(&apos; hello world &apos;); +----------------------------+| LTRIM(&apos; hello world &apos;) |+----------------------------+| hello world |+----------------------------+ RTRIM(str)返回删除了其拖后空格字符的字符串str。123456mysql&gt; select RTRIM(&apos; hello world &apos;); +----------------------------+| RTRIM(&apos; hello world &apos;) |+----------------------------+| hello world |+----------------------------+ TRIM([[BOTH | LEADING | TRAILING] [remstr] FROM] str)返回字符串str，其所有remstr前缀或后缀被删除了。如果没有修饰符BOTH、LEADING或TRAILING给出，BOTH被假定。如果remstr没被指定，空格被删除。12345678910111213141516171819202122232425mysql&gt; select TRIM(&apos; hello world &apos;); +---------------------------+| TRIM(&apos; hello world &apos;) |+---------------------------+| hello world |+---------------------------+mysql&gt; select TRIM(LEADING &apos;x&apos; FROM &apos;xxxbarxxx&apos;);+------------------------------------+| TRIM(LEADING &apos;x&apos; FROM &apos;xxxbarxxx&apos;) |+------------------------------------+| barxxx |+------------------------------------+mysql&gt; select TRIM(TRAILING &apos;x&apos; FROM &apos;xxxbarxxx&apos;); +-------------------------------------+| TRIM(TRAILING &apos;x&apos; FROM &apos;xxxbarxxx&apos;) |+-------------------------------------+| xxxbar |+-------------------------------------+mysql&gt; select TRIM(BOTH &apos;x&apos; FROM &apos;xxxbarxxx&apos;); +---------------------------------+| TRIM(BOTH &apos;x&apos; FROM &apos;xxxbarxxx&apos;) |+---------------------------------+| bar |+---------------------------------+该函数对多字节是可靠的。 SOUNDEX(str)返回str的一个同音字符串。听起来“大致相同”的2个字符串应该有相同的同音字符串。一个“标准”的同音字符串长是4个字符，但是SOUNDEX()函数返回一个任意长的字符串。你可以在结果上使用SUBSTRING()得到一个“标准”的 同音串。所有非数字字母字符在给定的字符串中被忽略。所有在A-Z之外的字符国际字母被当作元音。123456mysql&gt; select SOUNDEX(&apos;Hello&apos;);+------------------+| SOUNDEX(&apos;Hello&apos;) |+------------------+| H400 |+------------------+ SPACE(N)返回由N个空格字符组成的一个字符串。123456mysql&gt; select SPACE(32);+----------------------------------+| SPACE(32) |+----------------------------------+| |+----------------------------------+ REPLACE(str,from_str,to_str)返回字符串str，其字符串from_str的所有出现由字符串to_str代替。123456mysql&gt; select REPLACE(&apos;www.mysql.com&apos;, &apos;w&apos;, &apos;M&apos;); +------------------------------------+| REPLACE(&apos;www.mysql.com&apos;, &apos;w&apos;, &apos;M&apos;) |+------------------------------------+| MMM.mysql.com |+------------------------------------+ REPEAT(str,count)返回由重复countTimes次的字符串str组成的一个字符串。如果count &lt;= 0，返回一个空字符串。如果str或count是NULL，返回NULL。123456mysql&gt; select REPEAT(&apos;MySQL&apos;, 3);+--------------------+| REPEAT(&apos;MySQL&apos;, 3) |+--------------------+| MySQLMySQLMySQL |+--------------------+ REVERSE(str)返回颠倒字符顺序的字符串str。123456mysql&gt; select REVERSE(&apos;abc&apos;);+----------------+| REVERSE(&apos;abc&apos;) |+----------------+| cba |+----------------+ INSERT(str,pos,len,newstr)返回字符串str，在位置pos起始的子串且len个字符长得子串由字符串newstr代替。123456mysql&gt; select INSERT(&apos;Quadratic&apos;, 3, 5, &apos;What&apos;); +-----------------------------------+| INSERT(&apos;Quadratic&apos;, 3, 5, &apos;What&apos;) |+-----------------------------------+| QuWhatic |+-----------------------------------+ ELT(N,str1,str2,str3,…)如果N= 1，返回str1，如果N= 2，返回str2，等等。如果N小于1或大于参数个数，返回NULL。ELT()是FIELD()反运算。123456mysql&gt; select ELT(1, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;); +----------------------------+| ELT(1, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;) |+----------------------------+| A |+----------------------------+ FIELD(str,str1,str2,str3,…)返回str在str1, str2, str3, …清单的索引。如果str没找到，返回0。FIELD()是ELT()反运算。123456mysql&gt; select FIELD(&apos;F&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;EF&apos;);+--------------------------------------+| FIELD(&apos;F&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;EF&apos;) |+--------------------------------------+| 0 |+--------------------------------------+ FIND_IN_SET(str,strlist)如果字符串str在由N子串组成的表strlist之中，返回一个1到N的值。一个字符串表是被“,”分隔的子串组成的一个字符串。如果第一个参数是一个常数字符串并且第二个参数是一种类型为SET的列，FIND_IN_SET()函数被优化而使用位运算！如果str不是在strlist里面或如果strlist是空字符串，返回0。如果任何一个参数是NULL，返回NULL。如果第一个参数包含一个“,”，该函数将工作不正常。123456mysql&gt; SELECT FIND_IN_SET(&apos;C&apos;,&apos;A,B,C,D&apos;);+----------------------------+| FIND_IN_SET(&apos;C&apos;,&apos;A,B,C,D&apos;) |+----------------------------+| 3 |+----------------------------+ MAKE_SET(bits,str1,str2,…)返回一个集合 (包含由“,”字符分隔的子串组成的一个字符串)，由相应的位在bits集合中的的字符串组成。str1对应于位0，str2对应位1，等等。在str1, str2, …中的NULL串不添加到结果中。123456789101112mysql&gt; SELECT MAKE_SET(4,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;);+-------------------------+| MAKE_SET(4,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;) |+-------------------------+| c |+-------------------------+mysql&gt; SELECT MAKE_SET(1|4,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;);+---------------------------+| MAKE_SET(1|4,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;) |+---------------------------+| a,c |+---------------------------+ EXPORT_SET(bits,on,off,[separator,[number_of_bits]])返回一个字符串，在这里对于在“bits”中设定每一位，你得到一个“on”字符串，并且对于每个复位(reset)的位，你得到一个“off”字符串。每个字符串用“separator”分隔(缺省“,”)，并且只有“bits”的“number_of_bits” (缺省64)位被使用。123456mysql&gt; select EXPORT_SET(7,&apos;Y&apos;,&apos;N&apos;,&apos;,&apos;,6);+-----------------------------+| EXPORT_SET(7,&apos;Y&apos;,&apos;N&apos;,&apos;,&apos;,6) |+-----------------------------+| Y,Y,Y,N,N,N |+-----------------------------+ LCASE(str)、LOWER(str)返回字符串str，根据当前字符集映射(缺省是ISO-8859-1 Latin1)把所有的字符改变成小写。该函数对多字节是可靠的。123456mysql&gt; select LOWER(&apos;Imarkofu&apos;); +-------------------+| LOWER(&apos;Imarkofu&apos;) |+-------------------+| imarkofu |+-------------------+ UCASE(str)、UPPER(str)返回字符串str，根据当前字符集映射(缺省是ISO-8859-1 Latin1)把所有的字符改变成大写。该函数对多字节是可靠的。123456mysql&gt; select UPPER(&apos;Imarkofu&apos;);+-------------------+| UPPER(&apos;Imarkofu&apos;) |+-------------------+| IMARKOFU |+-------------------+ LOAD_FILE(file_name)读入文件并且作为一个字符串返回文件内容。文件必须在服务器上，你必须指定到文件的完整路径名，而且你必须有file权限。文件必须所有内容都是可读的并且小于max_allowed_packet。如果文件不存在或由于上面原因之一不能被读出，函数返回NULL。1234567mysql&gt; select load_file(&quot;/abc.txt&quot;); +-----------------------+| load_file(&quot;/abc.txt&quot;) |+-----------------------+| ABC |+-----------------------+ MySQL必要时自动变换数字为字符串，并且反过来也如此：123456789101112mysql&gt; SELECT 3+&quot;2&quot;;+-------+| 3+&quot;2&quot; |+-------+| 5 |+-------+mysql&gt; SELECT CONCAT(3+&quot;2&quot;,&apos; total&apos;);+------------------------+| CONCAT(3+&quot;2&quot;,&apos; total&apos;) |+------------------------+| 5 total |+------------------------+ 如果你想要明确地变换一个数字到一个字符串，把它作为参数传递到CONCAT()。如果字符串函数提供一个二进制字符串作为参数，结果字符串也是一个二进制字符串。被变换到一个字符串的数字被当作是一个二进制字符串。这仅影响比较;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux date命令]]></title>
      <url>%2F2016%2F12%2F29%2Flinux-date-command%2F</url>
      <content type="text"><![CDATA[date命令是显示或设置系统时间与日期。很多shell脚本里面需要打印不同格式的时间或日期，以及要根据时间和日期执行操作。延时通常用于脚本执行过程中提供一段等待的时间。日期可以以多种格式去打印，也可以使用命令设置固定的格式。在类UNIX系统中，日期被存储为一个整数，其大小为自世界标准时间（UTC）1970年1月1日0时0分0秒起流逝的秒数。 选项 -d&lt;字符串&gt;：显示字符串所指的日期与时间。字符串前后必须加上双引号；-s&lt;字符串&gt;：根据字符串来设置日期与时间。字符串前后必须加上双引号；-u：显示GMT； 参数 &lt;+时间日期格式&gt;：指定显示时使用的日期时间格式。 日期格式字符串列表 %H 小时，24小时制（00~23）%I 小时，12小时制（01~12）%k 小时，24小时制（0~23）%l 小时，12小时制（1~12）%M 分钟（00~59）%p 显示出AM或PM%r 显示时间，12小时制（hh:mm:ss %p）%s 从1970年1月1日00:00:00到目前经历的秒数%S 显示秒（00~59）%T 显示时间，24小时制（hh:mm:ss）%X 显示时间的格式（%H:%M:%S）%Z 显示时区，日期域（CST）%a 星期的简称（Sun~Sat）%A 星期的全称（Sunday~Saturday）%h,%b 月的简称（Jan~Dec）%B 月的全称（January~December）%c 日期和时间（Tue Nov 20 14:12:58 2012）%d 一个月的第几天（01~31）%x,%D 日期（mm/dd/yy）%j 一年的第几天（001~366）%m 月份（01~12）%w 一个星期的第几天（0代表星期天）%W 一年的第几个星期（00~53，星期一为第一天）%y 年的最后两个数字（1999则是99） 实例格式化输出 date +”%Y-%m-%d”2016-12-29 输出昨天日期： date -d “1 day ago” +”%Y-%m-%d”2016-12-28 2秒后输出： date -d “2 second” +”%Y-%m-%d %H:%M.%S”2016-12-29 14:37.22 传说中的 1234567890 秒： date -d “1970-01-01 1482990408 seconds” +”%Y-%m-%d %H:%m:%S”2016-12-29 05:12:48 普通转格式： date -d “2016-12-29” +”%Y/%m/%d %H:%M.%S”2016/12/29 00:00.00 apache格式转换： date -d “Dec 29, 2016 12:00:37 AM” +”%Y-%m-%d %H:%M.%S”2016-12-29 00:00.37 格式转换后时间游走： date -d “Dec 29, 2016 12:00:37 AM 2 year ago” +”%Y-%m-%d %H:%M.%S”2014-12-29 00:00.37 加减操作： date -s //设置当前时间，只有root权限才能设置，其他只能查看date -s 20161229 //设置成20120523，这样会把具体时间设置成空00:00:00date -s 01:01:01 //设置具体时间，不会对日期做更改date -s “01:01:01 2016-12-29” //这样可以设置全部时间date -s “01:01:01 20161229” //这样可以设置全部时间date -s “2016-12-29 01:01:01” //这样可以设置全部时间date -s “20161229 01:01:01” //这样可以设置全部时间]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SVN备份方案]]></title>
      <url>%2F2016%2F12%2F01%2Fsvn-backup%2F</url>
      <content type="text"><![CDATA[备份策略svn备份一般采用三种方式： 1）svnadmin dump2)svnadmin hotcopy3)svnsync 注意：svn备份不宜采用普通的文件拷贝方式（除非你备份的时候将库暂停），如copy命令、rsync命令。 优缺点分析第一种svnadmin dump是官方推荐的备份方式，优点是比较灵活，可以全量备份也可以增量备份，并提供了版本恢复机制。缺点是：如果版本比较大，如版本数增长到数万、数十万，那么dump的过程将非常慢；备份耗时，恢复更耗时；不利于快速进行灾难恢复。个人建议在版本数比较小的情况下使用这种备份方式。第二种svnadmin hotcopy原设计目的估计不是用来备份的，只能进行全量拷贝，不能进行增量备份；优点是：备份过程较快，灾难恢复也很快；如果备份机上已经搭建了svn服务，甚至不需要恢复，只需要进行简单配置即可切换到备份库上工作。缺点是：比较耗费硬盘，需要有较大的硬盘支持（俺的备份机有1TB空间，呵呵）。第三种svnsync实际上是制作2个镜像库，当一个坏了的时候，可以迅速切换到另一个。不过，必须svn1.4版本以上才支持这个功能。优点是：当制作成2个镜像库的时候起到双机实时备份的作用；缺点是：当作为2个镜像库使用时，没办法做到“想完全抛弃今天的修改恢复到昨晚的样子”；而当作为普通备份机制每日备份时，操作又较前2种方法麻烦。 备份方案以下是个人的备份方案：1、定期对线上SVN进行全量备份【目前每月1号】svnadmin dump /仓库路径/仓库名 |gzip &gt; ~/svn/仓库名_yyyyMMdd.gz将备份文件统一上传到其他设备的备份目录下进行存档 2、定期进行全量备份恢复测试解压.gz文件建立新的svn仓库导入存储库 svnadmin load 仓库路径 &lt; 解压的备份文件 3、对常用的几个SVN仓库进行热备份首先在其他设备上上编译安装SVN创建需要备份的仓库（这里以sm为例） svnadmin create 从仓库路径cp /从仓库路径/hooks/pre-revprop-change.tmpl /从仓库路径/hooks/pre-revprop-change 修改/从仓库路径/hooks/pre-revprop-change的内容，将最后的”exit 1”修改”exit 0”增加执行权限将主svn的对应仓库目录下的所有配置文件拷贝到从svn的仓库目录下覆盖替换 在从SVN上执行如下命令，进行初始化【这里尚未开始进行同步】 svnsync init 从仓库地址 主仓库地址svnsync init file:///从仓库路径 主仓库地址注意这里是三个/ 这里会询问当前Linux用户的密码，主SVN用户名，主SVN密码输入相应即可，然后会询问是否明文存储【这里建议输入no不存在，每次自行输入】 开始同步数据 svnsync sync file:///从仓库路径这里如果又用户正在提交SVN时，可能会出现获取锁失败的问题，需要清除锁的命令，再继续同步svn propdel svn:sync-lock –revprop -r0 file:///从仓库路径 同步完成之后，为了保证后续的SVN更新都能自动同步到从svn中需要在主SVN的/仓库路径/hooks下建立post-commit脚本，增加如下内容 svnsync sync –non-interactive 从仓库地址 –username 用户名 –password 密码 至此双击热备份即完成，可能还需要做的是定期抽查热备是否正常；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[windows server 2008 R2忘记administrator密码]]></title>
      <url>%2F2016%2F11%2F30%2Fwindows-forgets-the-administrator-password%2F</url>
      <content type="text"><![CDATA[对于一个专业的运维人员而言，可能收下有很多台设备需要管理，这里不免需要记录各种奇奇怪怪的密码，可能发生最北催的事情，莫过于忘记了自己维护设备的管理密码。忘记密码其实还是有解决方案的，只需要拿到一张系统的安装光盘。将光盘放入光驱当中，重启电脑，从光驱启动电脑，在选择“安装语言”的位置，按Shite+F10此时会弹出一个dos窗口，在这个dos窗口中执行如下命令1234cd windows\system32ren Magnify.exe Magnify1.exeren cmd.exe Magnify.exeexit 以上命令主要是用于替换掉放大镜窗口然后再次重启电脑，正常启动在需要输入密码的界面中，点击放大镜，打开放大镜会出现一个dos窗口，这就是我们上面的操作的目的然后执行如下命令1net user administrator Imarkofu123456 注：这里的Imarkofu123456即为重置的新密码，你可以根据自己的情况设置密码还有一点需要注意的是设置密码时不要使用特殊字符，只要数字大小写字母就可以了然后关闭窗口输入刚刚重置的密码即可登录了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CentOS 6.5安全加固及性能优化]]></title>
      <url>%2F2016%2F11%2F30%2Fcentos-safety-reinforcement-and-performance-optimization%2F</url>
      <content type="text"><![CDATA[说明：经常玩Linux系统的朋友多多少少也知道些系统参数优化和怎样增强系统安全性，系统默认的一些参数都是比较保守的，所以我们可以通过调整系统参数来提高系统内存、CPU、内核资源的占用，通过禁用不必要的服务、端口，来提高系统的安全性，更好的发挥系统的可用性。通过自己对Linux了解，对系统调优做了如下小结：操作系统：CentOS 6.5_x64最小化安装 1、主机名设置123[root@localhost~]# vi /etc/sysconfig/networkHOSTNAME=test.com[root@localhost~]# hostname test.com #临时生效 2、关闭SELinux1234[root@localhost~]# vi /etc/selinux/configSELINUX=disabled[root@localhost~]# setenforce #临时生效[root@localhost~]# getenforce #查看selinux状态 3、清空防火墙并设置规则12345678910[root@localhost~]# iptables -F #清楚防火墙规则[root@localhost~]# iptables -L #查看防火墙规则[root@localhost~]# iptables -A INPUT -p tcp --dport 80 -j ACCEPT[root@localhost~]# iptables -A INPUT -p tcp --dport 22 -j ACCEPT[root@localhost~]# iptables -A INPUT -p tcp --dport 53 -j ACCEPT[root@localhost~]# iptables -A INPUT -p udp --dport 53 -j ACCEPT[root@localhost~]# iptables -A INPUT -p udp --dport 123 -j ACCEPT[root@localhost~]# iptables -A INPUT -p icmp -j ACCEPT[root@localhost~]# iptables -P INPUT DROP[root@localhost~]# /etc/init.d/iptables save 根据需求开启相应端口 4、添加普通用户并进行sudo授权管理12345[root@localhost~]# useradd user[root@localhost~]# echo &quot;123456&quot; | passwd --stdin user #设置密码[root@localhost~]# vi /etc/sudoers #或visudo打开，添加user用户所有权限root ALL=(ALL) ALLuser ALL=(ALL) ALL 5、禁用root远程登录1234[root@localhost~]# vi /etc/ssh/sshd_configPermitRootLogin noPermitEmptyPasswords no #禁止空密码登录UseDNS no #关闭DNS查询 6、关闭不必要开机自启动服务12345678910111213[root@localhost~]# chkconfig auditd off[root@localhost~]# chkconfig blk-availablility off[root@localhost~]# chkconfig ip6tables off[root@localhost~]# chkconfig lvm2-monitor off[root@localhost~]# chkconfig netfs off[root@localhost~]# chkconfig udev-post off[root@localhost~]# chkconfig --list | grep 3:oncrond 0:off 1:off 2:on 3:on 4:on 5:on 6:offnetwork 0:off 1:off 2:on 3:on 4:on 5:on 6:offpostfix 0:off 1:off 2:on 3:on 4:on 5:on 6:offrsyslog 0:off 1:off 2:on 3:on 4:on 5:on 6:offsshd 0:off 1:off 2:on 3:on 4:on 5:on 6:off[root@localhost~]# 7、删除不必要的系统用户1234567891011121314151617181920212223242526272829[root@localhost~]# awk -F&quot;:&quot; &apos;&#123;print $1&#125;&apos; /etc/passwdrootbindaemonadmlpsyncshutdownhaltmailuucpoperatorgamesgopherftpnobodyvcsasaslauthpostfixsshdntp[root@localhost~]# userdel adm[root@localhost~]# userdel lp[root@localhost~]# userdel shutdown[root@localhost~]# userdel halt[root@localhost~]# userdel uucp[root@localhost~]# userdel operator[root@localhost~]# userdel games[root@localhost~]# userdel gopher 8、关闭重启ctl-alt-delete组合键12[root@localhost ~]# vi /etc/init/control-alt-delete.conf#exec /sbin/shutdown -r now &quot;Control-Alt-Deletepressed&quot; #注释掉 9、调整文件描述符大小123[root@localhost ~]# ulimit –n #默认是10241024[root@localhost ~]# echo &quot;ulimit -SHn 102400&quot;&gt;&gt; /etc/rc.local #设置开机自动生效 11、修改history记录12[root@localhost ~]# vi /etc/profile #修改记录10个HISTSIZE=10 12、同步系统时间1234[root@localhost ~]# cp /usr/share/zoneinfo/Asia/Shanghai/etc/localtime #设置Shanghai时区[root@localhost ~]# ntpdate cn.pool.ntp.org ；hwclock–w #同步时间并写入blos硬件时间[root@localhost ~]# crontab –e #设置任务计划每天零点同步一次0 0 * * * /usr/sbin/ntpdate cn.pool.ntp.org ; hwclock -w 13、内核参数优化123456789101112131415161718192021[root@localhost ~]# vi /etc/sysctl.conf #末尾添加如下参数net.ipv4.tcp_syncookies = 1 #1是开启SYN Cookies，当出现SYN等待队列溢出时，启用Cookies来处，理，可防范少量SYN攻击，默认是0关闭net.ipv4.tcp_tw_reuse = 1 #1是开启重用，允许讲TIME_AIT sockets重新用于新的TCP连接，默认是0关闭net.ipv4.tcp_tw_recycle = 1 #TCP失败重传次数，默认是15，减少次数可释放内核资源net.ipv4.ip_local_port_range = 4096 65000 #应用程序可使用的端口范围net.ipv4.tcp_max_tw_buckets = 5000 #系统同时保持TIME_WAIT套接字的最大数量，如果超出这个数字，TIME_WATI套接字将立刻被清除并打印警告信息，默认180000net.ipv4.tcp_max_syn_backlog = 4096 #进入SYN宝的最大请求队列，默认是1024net.core.netdev_max_backlog = 10240 #允许送到队列的数据包最大设备队列，默认300net.core.somaxconn = 2048 #listen挂起请求的最大数量，默认128net.core.wmem_default = 8388608 #发送缓存区大小的缺省值net.core.rmem_default = 8388608 #接受套接字缓冲区大小的缺省值（以字节为单位）net.core.rmem_max = 16777216 #最大接收缓冲区大小的最大值net.core.wmem_max = 16777216 #发送缓冲区大小的最大值net.ipv4.tcp_synack_retries = 2 #SYN-ACK握手状态重试次数，默认5net.ipv4.tcp_syn_retries = 2 #向外SYN握手重试次数，默认4net.ipv4.tcp_tw_recycle = 1 #开启TCP连接中TIME_WAIT sockets的快速回收，默认是0关闭net.ipv4.tcp_max_orphans = 3276800 #系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上，如果超出这个数字，孤儿连接将立即复位并打印警告信息net.ipv4.tcp_mem = 94500000 915000000 927000000net.ipv4.tcp_mem[0]:低于此值，TCP没有内存压力；net.ipv4.tcp_mem[1]:在此值下，进入内存压力阶段；net.ipv4.tcp_mem[2]:高于此值，TCP拒绝分配socket。内存单位是页，可根据物理内存大小进行调整，如果内存足够大的话，可适当往上调。上述内存单位是页，而不是字节。 至此CentOS 6.5_x64最小化安装系统基本优化调整完毕，需要重启下系统。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[centos 6.5 编译安装 mysql 5.5.40]]></title>
      <url>%2F2016%2F11%2F30%2Fcentos-compile-and-install-MySQL%2F</url>
      <content type="text"><![CDATA[在开始之前我们需要准备一些库文件。1[root@imarkofu ~]# yum install zlib-devel openssl-devel gcc-c++ gcc bison cmake ncurses-devel -y 一定要安装这些包， LZ之前没有安装就开始编译MySQL，踩了好多坑， 后来上网一查才发现需要这些文件和管理工具才行。因此一定要安装。还有如果大家编译过程中出错, 请一定要执行:1[root@imarkofu ~]# rm -f CMakeCache.txt 之后再继续安装。安装好之后我们来添加MySQL数据库需要的账户和目录：12345[root@imarkofu ~]# groupadd -r mysql[root@imarkofu ~]# useradd -g mysql -r -s /sbin/nologin mysql[root@imarkofu ~]# id mysql #确认用户[root@imarkofu ~]# mkdir /var/data/mysql -p #存放数据库文件[root@imarkofu ~]# chown mysql:mysql /var/data -R 下载MySQL源码包：mysql-5.5.40.tar.gz下载后上传到服务器12[root@imarkofu ~]# tar -xvf mysql-5.5.40.tar.gz -C /usr/local/src/[root@imarkofu ~]# cd /usr/local/src/mysql-5.5.40 cmake编译MySQL的一些常用选项：12345678910111213141516171819202122232425262728293031323334353637------------------------------------------------------------cmake mysql 编译安装:./configure -&gt; cmake ../configure --help -&gt; cmake -LH -&gt; ccmake .------------------------------------------------------------指定安装文件的安装路径常用选项-DCMAKE_INSTALL_PREFIX=/usr/local/mysql-DMYSQL_DATADIR=/data/mysql-DSYSCONFDIR=/etc------------------------------------------------------------默认编译的存储引擎包括: csv, myisma, myisammrg, heap. 若要安装其他存储引擎,可以使用类似如下的编译选项-DWITH_INNOBASE_STORAGE_ENGINE=1-DWITH_ARCHIVE_STORAGE_ENGINE=1-DWITH_BLACKHOLE_STORAGE_ENGINE=1------------------------------------------------------------若要明确指出不编译某存储引擎, 可以使用类似如下的选项:-DWITHOUT_&lt;ENGINE&gt;_STORAGE_ENGINE=1例如:-DWITHOUT_EXAMPLE_STORAGE_ENGINE=1-DWITHOUT_FEDERATED_STORAGE_ENGINE=1------------------------------------------------------------若要编译进其他功能, 如SSl等, 可使用类似如下选项来实现编译时使用某库文件或者, 或者不使用某库文件.-DWITH_READLINE=1-DWITH_SSL=system-DWITH_ZLIB=system-DWITH_LIBWRAP=0------------------------------------------------------------其他常用选项:-DMYSQL_TCP_PORT=3306-MYDQL_UNIX_ADDR=/tmp/mysql.sock-DENABLED_LOCAL_INFILE=1-DEXTRA_CHARSETS=all-DDEFAULT_CHARSET=utf8-DDEFAULT_COLLATION=utf8_general_ci-DWITH_DEBUG=0-DENABLE_PROFILING=1------------------------------------------------------------ 开始编译 12345678910111213[root@imarkofu mysql-5.5.40]# cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql-5.5.40 \-DMYSQL_DATADIR=/var/data/mysql \ #数据库目录-DSYSCONFDIR=/etc \ #配置文件目录-DWITH_INNOBASE_STORAGE_ENGINE=1 \ #启用InnoDB存储引擎-DWITH_ARCHIVE_STORAGE_ENGINE=1 \ #启用ARCHIVE存储引擎-DWITH_BLACKHOLE_STORAGE_ENGINE=1 \ #启用黑洞存储引擎-DWITH_READLINE=1 \-DWITH_SSL=system \ #启用SSL协议-DWITH_ZLIB=system \ #启用Zlib压缩-DWITH_LIBWRAP=0 \-DDEFAULT_CHARSET=utf8 \ #设置字符集utf8-DMYSQL_UNIX_ADDR=/tmp/mysql.sock \-DDEFAULT_COLLATION=utf8_general_ci 如果出现以下信息，那么恭喜你第一阶段的配置顺利完成了过程中如果出现错误也不要害怕， 因为你长经验的时刻就要来了， 通常是因为缺少了什么依赖的包而出现的问题， 你可以把你的错误信息铁道Google或者百度中去搜索。12345678910111213....(此处省略一万字)-- Performing Test HAVE_IB_GCC_ATOMIC_BUILTINS-- Performing Test HAVE_IB_GCC_ATOMIC_BUILTINS - Success-- Performing Test HAVE_IB_ATOMIC_PTHREAD_T_GCC-- Performing Test HAVE_IB_ATOMIC_PTHREAD_T_GCC - Success-- Check size of pthread_t-- Check size of pthread_t - done-- Performing Test HAVE_PEERCRED-- Performing Test HAVE_PEERCRED - Success-- Library mysqlclient depends on OSLIBS -lpthread;z;m;rt;/usr/lib64/libssl.so;/usr/lib64/libcrypto.so;dl-- Configuring done-- Generating done-- Build files have been written to: /usr/local/mysql-5.5.40 继续12345678910[root@imarkofu mysql-5.5.40]# make....(此处省略一万字)Scanning dependencies of target udf_example[100%] Building C object sql/CMakeFiles/udf_example.dir/udf_example.c.oLinking C shared module udf_example.so[100%] Built target udf_exampleScanning dependencies of target my_safe_process[100%] Building CXX object mysql-test/lib/My/SafeProcess/CMakeFiles/my_safe_process.dir/safe_process.cc.oLinking CXX executable my_safe_process[100%] Built target my_safe_process 如果没有报错，继续12345678910[root@imarkofu mysql-5.5.40]# make install....(此处省略一万字)-- Installing: /usr/local/mysql-5.5.40/man/man1/mysql_upgrade.1-- Installing: /usr/local/mysql-5.5.40/man/man1/mysqlslap.1-- Installing: /usr/local/mysql-5.5.40/man/man1/replace.1-- Installing: /usr/local/mysql-5.5.40/man/man1/mysql.1-- Installing: /usr/local/mysql-5.5.40/man/man1/mysql_setpermission.1-- Installing: /usr/local/mysql-5.5.40/man/man1/mysql_secure_installation.1-- Installing: /usr/local/mysql-5.5.40/man/man1/mysqlimport.1-- Installing: /usr/local/mysql-5.5.40/man/man8/mysqld.8 全部安装ok之后我们来配置下文档的权限123456789101112131415161718192021222324[root@imarkofu mysql-5.5.40]# chown :mysql /usr/local/mysql-5.5.40 -R[root@imarkofu mysql-5.5.40]# cd /usr/local/mysql-5.5.40/[root@imarkofu mysql-5.5.40]# chmod +x scripts/mysql_install_db[root@imarkofu mysql-5.5.40]# scripts/mysql_install_db --user=mysql --datadir=/var/data/mysql/ #执行初始化脚本....(此处省略一万字)./bin/mysqladmin -u root password &apos;new-password&apos;./bin/mysqladmin -u root -h imarkofu password &apos;new-password&apos; Alternatively you can run:./bin/mysql_secure_installation which will also give you the option of removing the testdatabases and anonymous user created by default. This isstrongly recommended for production servers. See the manual for more instructions. You can start the MySQL daemon with:cd . ; ./bin/mysqld_safe &amp; You can test the MySQL daemon with mysql-test-run.plcd ./mysql-test ; perl mysql-test-run.pl Please report any problems at http://bugs.mysql.com/ 如果你获得的信息和上面一样的话, 恭喜你, 你又离成功近了一步12[root@imarkofu mysql-5.5.40]# ls /var/data/mysql/ #看一下是否生成了文件mysql performance_schema test 如果是这样那么继续创建服务脚本123[root@imarkofu mysql-5.5.40]# cp support-files/mysql.server /etc/rc.d/init.d/mysqld [root@imarkofu mysql-5.5.40]# chmod +x /etc/rc.d/init.d/mysqld #添加mysqld执行权限[root@imarkofu mysql-5.5.40]# chkconfig --add mysqld #添加开机启动 创建配置文件1234567891011121314151617181920212223242526[root@imarkofu mysql-5.5.40]# mv /etc/my.cnf&#123;,.bak&#125;[root@imarkofu mysql-5.5.40]# cp support-files/my-large.cnf /etc/my.cnf[root@imarkofu mysql-5.5.40]# vim /etc/my.cnf#找到如下部分[mysqld]port = 3306socket = /tmp/mysql.sockskip-external-lockingkey_buffer_size = 256Mmax_allowed_packet = 1Mtable_open_cache = 256sort_buffer_size = 1Mread_buffer_size = 1Mread_rnd_buffer_size = 4Mmyisam_sort_buffer_size = 64Mthread_cache_size = 8query_cache_size= 16M# Try number of CPU&apos;s*2 for thread_concurrencythread_concurrency = 8datadir= /var/data/mysql #添加次行内容, 就是数据库文件存放路径:wq#保存退出[root@imarkofu mysql-5.5.40]# vim /etc/profile.d/mysql.shexport PATH=/usr/local/mysql-5.5.40/bin:$PATH #添加此行 好了，尝试着启动MySQL服务123456[root@imarkofu mysql-5.5.40]# service mysqld startStarting MySQL.. [ OK ][root@imarkofu mysql-5.5.40]#[root@imarkofu mysql-5.5.40]# ss -tnl| grep :3306 LISTEN 0 50 *:3306 *:* #发现正常监听 3306端口 距离胜利越来越近了然后配置MySQL管理员密码进行初始化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950[root@imarkofu mysql-5.5.40]# mysql #使用客户端登录Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 1Server version: 5.5.40-log Source distributionCopyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; #查看一下默认存在的用户mysql&gt; select user,password,host from mysql.user; +------+----------+-----------+| user | password | host |+------+----------+-----------+| root | | localhost || root | | imarkofu || root | | 127.0.0.1 || root | | ::1 || | | localhost || | | imarkofu |+------+----------+-----------+6 rows in set (0.00 sec)mysql&gt; #删除默认存在的账户, 要求用户只能从本地服务器访问数据库mysql&gt; delete from mysql.user where host!=&apos;localhost&apos;; Query OK, 4 rows affected (0.00 sec)#修改root管理员账号密码mysql&gt; update mysql.user set password=PASSWORD(&apos;p@ssw0rd&apos;) where user=&apos;root&apos;; Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0 #更新数据库mysql&gt; FLUSH PRIVILEGES;Query OK, 0 rows affected (0.00 sec) #看一下修改后的结果mysql&gt; select user,password,host from mysql.user;+------+-------------------------------------------+-----------+| user | password | host |+------+-------------------------------------------+-----------+| root | *D7E39C3AF517EC9EF7086223B036E0B4F22821F8 | localhost || | | localhost |+------+-------------------------------------------+-----------+2 rows in set (0.00 sec)mysql&gt; \qBye[root@imarkofu mysql-5.5.40]# 然后就可以使用新密码登陆了1234567891011[root@imarkofu mysql-5.5.40]# mysql -u root -h localhost -pEnter password: #输入刚才设置的密码Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 4Server version: 5.5.40-log Source distributionCopyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; 好了MySQL到此 就安装成功了对了，忘记了导入开发的库文件了， ok 很快就好123456789[root@imarkofu mysql-5.5.40]# ln -sv /usr/local/mysql/include/ /usr/include/mysql #软连接到系统库中[root@imarkofu mysql-5.5.40]# vim /etc/ld.so.conf.d/mysql.conf #编辑这个文件, 并且添加如下路径/usr/local/mysql-5.5.40/lib[root@imarkofu mysql-5.5.40]# ldconfig #重新加载库文件[root@imarkofu mysql-5.5.40]# ldconfig -p | grep mysql #让我们来检查下是不是加载好了 libmysqlclient_r.so.16 (libc6,x86-64) =&gt; /usr/lib64/mysql/libmysqlclient_r.so.16 libmysqlclient.so.18 (libc6,x86-64) =&gt; /usr/local/mysql-5.5.40/lib/libmysqlclient.so.18 libmysqlclient.so.16 (libc6,x86-64) =&gt; /usr/lib64/mysql/libmysqlclient.so.16 libmysqlclient.so (libc6,x86-64) =&gt; /usr/local/mysql-5.5.40/lib/libmysqlclient.so 至此，MySQL5.5.40 编译安装完成]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mysql in 子查询 效率慢 优化]]></title>
      <url>%2F2016%2F11%2F30%2Foptimize-mysql-in-subqueries%2F</url>
      <content type="text"><![CDATA[现在的CMS系统、博客系统、BBS等都喜欢使用标签tag作交叉链接，因此我也尝鲜用了下。但用了后发现我想查询某个tag的文章列表时速度很慢，达到5秒之久！百思不解(后来终于解决)，我的表结构是下面这样的，文章只有690篇。文章表article(id,title,content)标签表tag(tid,tag_name)标签文章中间表article_tag(id,tag_id,article_id)其中有个标签的tid是135，我帮查询标签tid是135的文章列表用以下语句时发现速度好慢,我文章才690篇 select id,title from article where id in(select article_id from article_tag where tag_id=135) 其中这条速度很快： select article_id from article_tag where tag_id=135 查询结果是五篇文章，id为428,429,430,431,432我用写死的方式用下面sql来查文章也很快 select id,title from article where id in(428,429,430,431,432) 我在SqlServer中好像不会这样慢，不知MySQL怎样写好点，也想不出慢在哪里。后来我找到了解决方法： select id,title from article where id in(select article_id from (select article_id from article_tag where tag_id=135) as tbt) 其它解决方法：（举例） select * from abc_number_prop where number_id in (select number_id from abc_number_phone where phone = ‘82306839’); 为了节省篇幅，省略了输出内容，下同。 67 rows in set (12.00 sec) 只有67行数据返回，却花了12秒，而系统中可能同时会有很多这样的查询，系统肯定扛不住。用desc看一下(注：explain也可) mysql&gt;desc select * from abc_number_prop where number_id in (select number_id from abc_number_phone where phone = ‘82306839’);+—-+——————–+——————+——–+—————–+——-+———+————+———+————————–+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+——————–+——————+——–+—————–+——-+———+————+———+————————–+| 1 | PRIMARY | abc_number_prop | ALL | NULL | NULL | NULL | NULL | 2679838 | Using where || 2 | DEPENDENT SUBQUERY | abc_number_phone | eq_ref | phone,number_id | phone | 70 | const,func | 1 | Using where; Using index |+—-+——————–+——————+——–+—————–+——-+———+————+———+————————–+2 rows in set (0.00 sec) 从上面的信息可以看出，在执行此查询时会扫描两百多万行，难道是没有创建索引吗，看一下 mysql&gt;show index from abc_number_phone;+——————+————+————-+————–+—————–+———–+————-+———-+——–+——+————+———+—————+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+——————+————+————-+————–+—————–+———–+————-+———-+——–+——+————+———+—————+| abc_number_phone | 0 | PRIMARY | 1 | number_phone_id | A | 36879 | NULL | NULL | | BTREE | | || abc_number_phone | 0 | phone | 1 | phone | A | 36879 | NULL | NULL | | BTREE | | || abc_number_phone | 0 | phone | 2 | number_id | A | 36879 | NULL | NULL | | BTREE | | || abc_number_phone | 1 | number_id | 1 | number_id | A | 36879 | NULL | NULL | | BTREE | | || abc_number_phone | 1 | created_by | 1 | created_by | A | 36879 | NULL | NULL | | BTREE | | || abc_number_phone | 1 | modified_by | 1 | modified_by | A | 36879 | NULL | NULL | YES | BTREE | | |+——————+————+————-+————–+—————–+———–+————-+———-+——–+——+————+———+—————+6 rows in set (0.06 sec) mysql&gt;show index from abc_number_prop;+—————–+————+————-+————–+—————-+———–+————-+———-+——–+——+————+———+—————+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+—————–+————+————-+————–+—————-+———–+————-+———-+——–+——+————+———+—————+| abc_number_prop | 0 | PRIMARY | 1 | number_prop_id | A | 311268 | NULL | NULL | | BTREE | | || abc_number_prop | 1 | number_id | 1 | number_id | A | 311268 | NULL | NULL | | BTREE | | || abc_number_prop | 1 | created_by | 1 | created_by | A | 311268 | NULL | NULL | | BTREE | | || abc_number_prop | 1 | modified_by | 1 | modified_by | A | 311268 | NULL | NULL | YES | BTREE | | |+—————–+————+————-+————–+—————-+———–+————-+———-+——–+——+————+———+—————+4 rows in set (0.15 sec) 从上面的输出可以看出，这两张表在number_id字段上创建了索引的。看看子查询本身有没有问题。 mysql&gt;desc select number_id from abc_number_phone where phone = ‘82306839’;+—-+————-+——————+——+—————+——-+———+——-+——+————————–+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+————-+——————+——+—————+——-+———+——-+——+————————–+| 1 | SIMPLE | abc_number_phone | ref | phone | phone | 66 | const | 6 | Using where; Using index |+—-+————-+——————+——+—————+——-+———+——-+——+————————–+1 row in set (0.00 sec) 没有问题，只需要扫描几行数据，索引起作用了。查询出来看看mysql&gt;select number_id from abc_number_phone where phone = ‘82306839’; +———–+| number_id |+———–+| 8585 || 10720 || 148644 || 151307 || 170691 || 221897 |+———–+6 rows in set (0.00 sec) 直接把子查询得到的数据放到上面的查询中 mysql&gt; select * from abc_number_prop where number_id in (8585, 10720, 148644, 151307, 170691, 221897);67 rows in set (0.03 sec) 速度也快，看来MySQL在处理子查询的时候是不够好。我在MySQL 5.1.42 和 MySQL 5.5.19 都进行了尝试，都有这个问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS获取当前对象大小属性以及屏幕分辨率属性等]]></title>
      <url>%2F2016%2F11%2F30%2Fgets-the-screen-properties-by-JS%2F</url>
      <content type="text"><![CDATA[JS获取当前对象大小属性以及屏幕分辨率属性等123456789101112131415161718192021222324&lt;script type="text/javascript"&gt;function getInfo()&#123; var s = ""; s += " 网页可见区域宽："+ document.body.clientWidth+"\n"; s += " 网页可见区域高："+ document.body.clientHeight+"\n"; s += " 网页可见区域宽："+ document.body.offsetWidth + " (包括边线和滚动条的宽)"+"\n"; s += " 网页可见区域高："+ document.body.offsetHeight + " (包括边线的宽)"+"\n"; s += " 网页正文全文宽："+ document.body.scrollWidth+"\n"; s += " 网页正文全文高："+ document.body.scrollHeight+"\n"; s += " 网页被卷去的高(ff)："+ document.body.scrollTop+"\n"; s += " 网页被卷去的高(ie)："+ document.documentElement.scrollTop+"\n"; s += " 网页被卷去的左："+ document.body.scrollLeft+"\n"; s += " 网页正文部分上："+ window.screenTop+"\n"; s += " 网页正文部分左："+ window.screenLeft+"\n"; s += " 屏幕分辨率的高："+ window.screen.height+"\n"; s += " 屏幕分辨率的宽："+ window.screen.width+"\n"; s += " 屏幕可用工作区高度："+ window.screen.availHeight+"\n"; s += " 屏幕可用工作区宽度："+ window.screen.availWidth+"\n"; s += " 你的屏幕设置是 "+ window.screen.colorDepth +" 位彩色"+"\n"; s += " 你的屏幕设置 "+ window.screen.deviceXDPI +" 像素/英寸"+"\n"; alert (s);&#125;getInfo();&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Redis的redis.conf中文版（基于2.4）]]></title>
      <url>%2F2016%2F11%2F29%2Ftranslation-redid-conf%2F</url>
      <content type="text"><![CDATA[redis 2.4的conf文件的中文翻译，大致参考。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376# Redis示例配置文件# 注意单位问题：当需要设置内存大小的时候，可以使用类似1k、5GB、4M这样的常见格式：## 1k =&gt; 1000 bytes# 1kb =&gt; 1024 bytes# 1m =&gt; 1000000 bytes# 1mb =&gt; 1024*1024 bytes# 1g =&gt; 1000000000 bytes# 1gb =&gt; 1024*1024*1024 bytes## 单位是大小写不敏感的，所以1GB 1Gb 1gB的写法都是完全一样的。# Redis默认是不作为守护进程来运行的。你可以把这个设置为&quot;yes&quot;让它作为守护进程来运行。# 注意，当作为守护进程的时候，Redis会把进程ID写到 /var/run/redis.piddaemonize no# 当以守护进程方式运行的时候，Redis会把进程ID默认写到 /var/run/redis.pid。你可以在这里修改路径。pidfile /var/run/redis.pid# 接受连接的特定端口，默认是6379。# 如果端口设置为0，Redis就不会监听TCP套接字。port 6379# 如果你想的话，你可以绑定单一接口；如果这里没单独设置，那么所有接口的连接都会被监听。## bind 127.0.0.1# 指定用来监听连接的unxi套接字的路径。这个没有默认值，所以如果你不指定的话，Redis就不会通过unix套接字来监听。## unixsocket /tmp/redis.sock# unixsocketperm 755#一个客户端空闲多少秒后关闭连接。(0代表禁用，永不关闭)timeout 0# 设置服务器调试等级。# 可能值：# debug （很多信息，对开发/测试有用）# verbose （很多精简的有用信息，但是不像debug等级那么多）# notice （适量的信息，基本上是你生产环境中需要的程度）# warning （只有很重要/严重的信息会记录下来）loglevel verbose# 指明日志文件名。也可以使用&quot;stdout&quot;来强制让Redis把日志信息写到标准输出上。# 注意：如果Redis以守护进程方式运行，而你设置日志显示到标准输出的话，那么日志会发送到 /dev/nulllogfile stdout# 要使用系统日志记录器很简单，只要设置 &quot;syslog-enabled&quot; 为 &quot;yes&quot; 就可以了。# 然后根据需要设置其他一些syslog参数就可以了。# syslog-enabled no# 指明syslog身份# syslog-ident redis# 指明syslog的设备。必须是一个用户或者是 LOCAL0 ~ LOCAL7 之一。# syslog-facility local0# 设置数据库个数。默认数据库是 DB 0，你可以通过SELECT &lt;dbid&gt; WHERE dbid（0～&apos;databases&apos; - 1）来为每个连接使用不同的数据库。databases 16################################ 快照 ################################### 把数据库存到磁盘上:## save &lt;seconds&gt; &lt;changes&gt;# # 会在指定秒数和数据变化次数之后把数据库写到磁盘上。## 下面的例子将会进行把数据写入磁盘的操作:# 900秒（15分钟）之后，且至少1次变更# 300秒（5分钟）之后，且至少10次变更# 60秒之后，且至少10000次变更## 注意：你要想不写磁盘的话就把所有 &quot;save&quot; 设置注释掉就行了。save 900 1save 300 10save 60 10000# 当导出到 .rdb 数据库时是否用LZF压缩字符串对象。# 默认设置为 &quot;yes&quot;，所以几乎总是生效的。# 如果你想节省CPU的话你可以把这个设置为 &quot;no&quot;，但是如果你有可压缩的key的话，那数据文件就会更大了。rdbcompression yes# 数据库的文件名dbfilename dump.rdb# 工作目录## 数据库会写到这个目录下，文件名就是上面的 &quot;dbfilename&quot; 的值。# # 累加文件也放这里。# # 注意你这里指定的必须是目录，不是文件名。dir ./################################# 同步 ################################### 主从同步。通过 slaveof 配置来实现Redis实例的备份。# 注意，这里是本地从远端复制数据。也就是说，本地可以有不同的数据库文件、绑定不同的IP、监听不同的端口。## slaveof &lt;masterip&gt; &lt;masterport&gt;# 如果master设置了密码（通过下面的 &quot;requirepass&quot; 选项来配置），那么slave在开始同步之前必须进行身份验证，否则它的同步请求会被拒绝。## masterauth &lt;master-password&gt;# 当一个slave失去和master的连接，或者同步正在进行中，slave的行为有两种可能：## 1) 如果 slave-serve-stale-data 设置为 &quot;yes&quot; (默认值)，slave会继续响应客户端请求，可能是正常数据，也可能是还没获得值的空数据。# 2) 如果 slave-serve-stale-data 设置为 &quot;no&quot;，slave会回复&quot;正在从master同步（SYNC with master in progress）&quot;来处理各种请求，除了 INFO 和 SLAVEOF 命令。#slave-serve-stale-data yes# slave根据指定的时间间隔向服务器发送ping请求。# 时间间隔可以通过 repl_ping_slave_period 来设置。# 默认10秒。## repl-ping-slave-period 10# 下面的选项设置了大块数据I/O、向master请求数据和ping响应的过期时间。# 默认值60秒。## 一个很重要的事情是：确保这个值比 repl-ping-slave-period 大，否则master和slave之间的传输过期时间比预想的要短。## repl-timeout 60################################## 安全 #################################### 要求客户端在处理任何命令时都要验证身份和密码。# 这在你信不过来访者时很有用。## 为了向后兼容的话，这段应该注释掉。而且大多数人不需要身份验证（例如：它们运行在自己的服务器上。）# # 警告：因为Redis太快了，所以居心不良的人可以每秒尝试150k的密码来试图破解密码。# 这意味着你需要一个高强度的密码，否则破解太容易了。## requirepass foobared# 命令重命名## 在共享环境下，可以为危险命令改变名字。比如，你可以为 CONFIG 改个其他不太容易猜到的名字，这样你自己仍然可以使用，而别人却没法做坏事了。## 例如:## rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52## 甚至也可以通过给命令赋值一个空字符串来完全禁用这条命令：## rename-command CONFIG &quot;&quot;################################### 限制 ###################################### 设置最多同时连接客户端数量。# 默认没有限制，这个关系到Redis进程能够打开的文件描述符数量。# 特殊值&quot;0&quot;表示没有限制。# 一旦达到这个限制，Redis会关闭所有新连接并发送错误&quot;达到最大用户数上限（max number of clients reached）&quot;## maxclients 128# 不要用比设置的上限更多的内存。一旦内存使用达到上限，Redis会根据选定的回收策略（参见：maxmemmory-policy）删除key。## 如果因为删除策略问题Redis无法删除key，或者策略设置为 &quot;noeviction&quot;，Redis会回复需要更多内存的错误信息给命令。# 例如，SET,LPUSH等等。但是会继续合理响应只读命令，比如：GET。## 在使用Redis作为LRU缓存，或者为实例设置了硬性内存限制的时候（使用 &quot;noeviction&quot; 策略）的时候，这个选项还是满有用的。## 警告：当一堆slave连上达到内存上限的实例的时候，响应slave需要的输出缓存所需内存不计算在使用内存当中。# 这样当请求一个删除掉的key的时候就不会触发网络问题／重新同步的事件，然后slave就会收到一堆删除指令，直到数据库空了为止。## 简而言之，如果你有slave连上一个master的话，那建议你把master内存限制设小点儿，确保有足够的系统内存用作输出缓存。# （如果策略设置为&quot;noeviction&quot;的话就不无所谓了）## maxmemory &lt;bytes&gt;# 内存策略：如果达到内存限制了，Redis如何删除key。你可以在下面五个策略里面选：# # volatile-lru -&gt; 根据LRU算法生成的过期时间来删除。# allkeys-lru -&gt; 根据LRU算法删除任何key。# volatile-random -&gt; 根据过期设置来随机删除key。# allkeys-&gt;random -&gt; 无差别随机删。# volatile-ttl -&gt; 根据最近过期时间来删除（辅以TTL）# noeviction -&gt; 谁也不删，直接在写操作时返回错误。# # 注意：对所有策略来说，如果Redis找不到合适的可以删除的key都会在写操作时返回一个错误。## 这里涉及的命令：set setnx setex append# incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd# sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby# zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby# getset mset msetnx exec sort## 默认值如下：## maxmemory-policy volatile-lru# LRU和最小TTL算法的实现都不是很精确，但是很接近（为了省内存），所以你可以用样例做测试。# 例如：默认Redis会检查三个key然后取最旧的那个，你可以通过下面的配置项来设置样本的个数。## maxmemory-samples 3############################## 纯累加模式 ################################ 默认情况下，Redis是异步的把数据导出到磁盘上。这种情况下，当Redis挂掉的时候，最新的数据就丢了。# 如果不希望丢掉任何一条数据的话就该用纯累加模式：一旦开启这个模式，Redis会把每次写入的数据在接收后都写入 appendonly.aof 文件。# 每次启动时Redis都会把这个文件的数据读入内存里。## 注意，异步导出的数据库文件和纯累加文件可以并存（你得把上面所有&quot;save&quot;设置都注释掉，关掉导出机制）。# 如果纯累加模式开启了，那么Redis会在启动时载入日志文件而忽略导出的 dump.rdb 文件。## 重要：查看 BGREWRITEAOF 来了解当累加日志文件太大了之后，怎么在后台重新处理这个日志文件。appendonly no# 纯累加文件名字（默认：&quot;appendonly.aof&quot;）# appendfilename appendonly.aof# fsync() 请求操作系统马上把数据写到磁盘上，不要再等了。# 有些操作系统会真的把数据马上刷到磁盘上；有些则要磨蹭一下，但是会尽快去做。## Redis支持三种不同的模式：## no：不要立刻刷，只有在操作系统需要刷的时候再刷。比较快。# always：每次写操作都立刻写入到aof文件。慢，但是最安全。# everysec：每秒写一次。折衷方案。## 默认的 &quot;everysec&quot; 通常来说能在速度和数据安全性之间取得比较好的平衡。# 如果你真的理解了这个意味着什么，那么设置&quot;no&quot;可以获得更好的性能表现（如果丢数据的话，则只能拿到一个不是很新的快照）；# 或者相反的，你选择 &quot;always&quot; 来牺牲速度确保数据安全、完整。## 如果拿不准，就用 &quot;everysec&quot;# appendfsync alwaysappendfsync everysec# appendfsync no# 如果AOF的同步策略设置成 &quot;always&quot; 或者 &quot;everysec&quot;，那么后台的存储进程（后台存储或写入AOF日志）会产生很多磁盘I/O开销。# 某些Linux的配置下会使Redis因为 fsync() 而阻塞很久。# 注意，目前对这个情况还没有完美修正，甚至不同线程的 fsync() 会阻塞我们的 write(2) 请求。## 为了缓解这个问题，可以用下面这个选项。它可以在 BGSAVE 或 BGREWRITEAOF 处理时阻止 fsync()。# # 这就意味着如果有子进程在进行保存操作，那么Redis就处于&quot;不可同步&quot;的状态。# 这实际上是说，在最差的情况下可能会丢掉30秒钟的日志数据。（默认Linux设定）# # 如果你有延迟的问题那就把这个设为 &quot;yes&quot;，否则就保持 &quot;no&quot;，这是保存持久数据的最安全的方式。no-appendfsync-on-rewrite no# 自动重写AOF文件## 如果AOF日志文件大到指定百分比，Redis能够通过 BGREWRITEAOF 自动重写AOF日志文件。# # 工作原理：Redis记住上次重写时AOF日志的大小（或者重启后没有写操作的话，那就直接用此时的AOF文件），# 基准尺寸和当前尺寸做比较。如果当前尺寸超过指定比例，就会触发重写操作。## 你还需要指定被重写日志的最小尺寸，这样避免了达到约定百分比但尺寸仍然很小的情况还要重写。## 指定百分比为0会禁用AOF自动重写特性。auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb################################## 慢查询日志 #################################### Redis慢查询日志可以记录超过指定时间的查询。运行时间不包括各种I/O时间。# 例如：连接客户端，发送响应数据等。只计算命令运行的实际时间（这是唯一一种命令运行线程阻塞而无法同时为其他请求服务的场景）# # 你可以为慢查询日志配置两个参数：一个是超标时间，单位为微妙，记录超过个时间的命令。# 另一个是慢查询日志长度。当一个新的命令被写进日志的时候，最老的那个记录会被删掉。## 下面的时间单位是微秒，所以1000000就是1秒。注意，负数时间会禁用慢查询日志，而0则会强制记录所有命令。slowlog-log-slower-than 10000# 这个长度没有限制。只要有足够的内存就行。你可以通过 SLOWLOG RESET 来释放内存。（译者注：日志居然是在内存里的Orz）slowlog-max-len 128################################ 虚拟内存 ################################## 警告！虚拟内存在Redis 2.4是反对的。### 非常不鼓励使用虚拟内存！！# 虚拟内存可以使Redis在内存不够的情况下仍然可以将所有数据序列保存在内存里。# 为了做到这一点，高频key会调到内存里，而低频key会转到交换文件里，就像操作系统使用内存页一样。## 要使用虚拟内存，只要把 &quot;vm-enabled&quot; 设置为 &quot;yes&quot;，并根据需要设置下面三个虚拟内存参数就可以了。vm-enabled no# vm-enabled yes# 这是交换文件的路径。估计你猜到了，交换文件不能在多个Redis实例之间共享，所以确保每个Redis实例使用一个独立交换文件。## 最好的保存交换文件（被随机访问）的介质是固态硬盘（SSD）。## *** 警告 *** 如果你使用共享主机，那么默认的交换文件放到 /tmp 下是不安全的。# 创建一个Redis用户可写的目录，并配置Redis在这里创建交换文件。vm-swap-file /tmp/redis.swap# &quot;vm-max-memory&quot; 配置虚拟内存可用的最大内存容量。# 如果交换文件还有空间的话，所有超标部分都会放到交换文件里。## &quot;vm-max-memory&quot; 设置为0表示系统会用掉所有可用内存。# 这默认值不咋地，只是把你能用的内存全用掉了，留点余量会更好。# 例如，设置为剩余内存的60%-80%。vm-max-memory 0# Redis交换文件是分成多个数据页的。# 一个可存储对象可以被保存在多个连续页里，但是一个数据页无法被多个对象共享。# 所以，如果你的数据页太大，那么小对象就会浪费掉很多空间。# 如果数据页太小，那用于存储的交换空间就会更少（假定你设置相同的数据页数量）## 如果你使用很多小对象，建议分页尺寸为64或32个字节。# 如果你使用很多大对象，那就用大一些的尺寸。# 如果不确定，那就用默认值 :)vm-page-size 32# 交换文件里数据页总数。# 根据内存中分页表（已用/未用的数据页分布情况），磁盘上每8个数据页会消耗内存里1个字节。## 交换区容量 = vm-page-size * vm-pages## 根据默认的32字节的数据页尺寸和134217728的数据页数来算，Redis的数据页文件会占4GB，而内存里的分页表会消耗16MB内存。## 为你的应验程序设置最小且够用的数字比较好，下面这个默认值在大多数情况下都是偏大的。vm-pages 134217728# 同时可运行的虚拟内存I/O线程数。# 这些线程可以完成从交换文件进行数据读写的操作，也可以处理数据在内存与磁盘间的交互和编码/解码处理。# 多一些线程可以一定程度上提高处理效率，虽然I/O操作本身依赖于物理设备的限制，不会因为更多的线程而提高单次读写操作的效率。## 特殊值0会关闭线程级I/O，并会开启阻塞虚拟内存机制。vm-max-threads 4############################### 高级配置 ################################ 当有大量数据时，适合用哈希编码（需要更多的内存），元素数量上限不能超过给定限制。# 你可以通过下面的选项来设定这些限制：hash-max-zipmap-entries 512hash-max-zipmap-value 64# 与哈希相类似，数据元素较少的情况下，可以用另一种方式来编码从而节省大量空间。# 这种方式只有在符合下面限制的时候才可以用：list-max-ziplist-entries 512list-max-ziplist-value 64# 还有这样一种特殊编码的情况：数据全是64位无符号整型数字构成的字符串。# 下面这个配置项就是用来限制这种情况下使用这种编码的最大上限的。set-max-intset-entries 512# 与第一、第二种情况相似，有序序列也可以用一种特别的编码方式来处理，可节省大量空间。# 这种编码只适合长度和元素都符合下面限制的有序序列：zset-max-ziplist-entries 128zset-max-ziplist-value 64# 哈希刷新，每100个CPU毫秒会拿出1个毫秒来刷新Redis的主哈希表（顶级键值映射表）。# redis所用的哈希表实现（见dict.c）采用延迟哈希刷新机制：你对一个哈希表操作越多，哈希刷新操作就越频繁；# 反之，如果服务器非常不活跃那么也就是用点内存保存哈希表而已。# # 默认是每秒钟进行10次哈希表刷新，用来刷新字典，然后尽快释放内存。## 建议：# 如果你对延迟比较在意的话就用 &quot;activerehashing no&quot;，每个请求延迟2毫秒不太好嘛。# 如果你不太在意延迟而希望尽快释放内存的话就设置 &quot;activerehashing yes&quot;。activerehashing yes################################## 包含 #################################### 包含一个或多个其他配置文件。# 这在你有标准配置模板但是每个redis服务器又需要个性设置的时候很有用。# 包含文件特性允许你引人其他配置文件，所以好好利用吧。## include /path/to/local.conf# include /path/to/other.conf]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HashSet、LinkedHashSet、TreeSet使用区别]]></title>
      <url>%2F2016%2F11%2F29%2Fthe-difference-of-HashSet-LinkedHashSet-TreeSet%2F</url>
      <content type="text"><![CDATA[HashSet：哈希表是通过使用称为散列法的机制来存储信息的，元素并没有以某种特定顺序来存放；LinkedHashSet：以元素插入的顺序来维护集合的链接表，允许以插入的顺序在集合中迭代；TreeSet：提供一个使用树结构存储Set接口的实现，对象以升序顺序存储，访问和遍历的时间很快。用例代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.HashSet; import java.util.LinkedHashSet; import java.util.TreeSet; /** * @description 几个set的比较 * HashSet：哈希表是通过使用称为散列法的机制来存储信息的，元素并没有以某种特定顺序来存放； * LinkedHashSet：以元素插入的顺序来维护集合的链接表，允许以插入的顺序在集合中迭代； * TreeSet：提供一个使用树结构存储Set接口的实现，对象以升序顺序存储，访问和遍历的时间很快。 * @author gbwl_cgl * */ public class SetDemo &#123; public static void main(String[] args) &#123; HashSet&lt;String&gt; hs = new HashSet&lt;String&gt;(); hs.add("B"); hs.add("A"); hs.add("D"); hs.add("E"); hs.add("C"); hs.add("F"); System.out.println("HashSet 顺序:\n"+hs); LinkedHashSet&lt;String&gt; lhs = new LinkedHashSet&lt;String&gt;(); lhs.add("B"); lhs.add("A"); lhs.add("D"); lhs.add("E"); lhs.add("C"); lhs.add("F"); System.out.println("LinkedHashSet 顺序:\n"+lhs); TreeSet&lt;String&gt; ts = new TreeSet&lt;String&gt;(); ts.add("B"); ts.add("A"); ts.add("D"); ts.add("E"); ts.add("C"); ts.add("F"); System.out.println("TreeSet 顺序:\n"+ts); &#125; &#125; 输出效果： HashSet 顺序: [D, E, F, A, B, C]LinkedHashSet 顺序: [B, A, D, E, C, F]TreeSet 顺序: [A, B, C, D, E, F]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java集合间的相互转换]]></title>
      <url>%2F2016%2F11%2F29%2Fjava-collection-transformation%2F</url>
      <content type="text"><![CDATA[代码演示List&lt;–&gt;数组、List&lt;–&gt;Set、数组&lt;–&gt;Set、Map将键转化为Set、Map将值转化为Set、Map将值转化为List等集合常用转化操作。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.ArrayList;import java.util.Arrays;import java.util.HashMap;import java.util.HashSet;import java.util.List;import java.util.Map;import java.util.Set;/** * @Title: CollectionConversion.java&lt;br&gt; * @package: com.imarkofu.demo&lt;br&gt; * @Description:集合转换&lt;br&gt; * @author gbwl&lt;br&gt; * @date 2015年5月11日 下午3:57:01&lt;br&gt; */public class CollectionConversion &#123; public static void main(String[] args) &#123; // List--&gt;数组 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("蹇伟"); list.add("Jerval"); list.add("杰威"); Object[] objects = list.toArray();// 返回Object数组 System.out.println("objects:" + Arrays.toString(objects)); String[] strings1 = new String[list.size()]; list.toArray(strings1);// 将转化后的数组放入已经创建好的对象中 System.out.println("strings1:" + Arrays.toString(strings1)); String[] strings2 = list.toArray(new String[0]);// 将转化后的数组赋给新对象 System.out.println("strings2:" + Arrays.toString(strings2)); // 数组--&gt;List String[] ss = &#123; "JJ", "KK" &#125;; List&lt;String&gt; list1 = Arrays.asList(ss); List&lt;String&gt; list2 = Arrays.asList("AAA", "BBB"); System.out.println(list1); System.out.println(list2); // List--&gt;Set List&lt;String&gt; list3 = new ArrayList&lt;String&gt;(new HashSet&lt;String&gt;()); // Set--&gt;List Set&lt;String&gt; set = new HashSet&lt;String&gt;(new ArrayList&lt;String&gt;()); // 数组--&gt;Set String[] strs = &#123; "AA", "BB" &#125;; Set&lt;String&gt; set2 = new HashSet&lt;String&gt;(Arrays.asList(strs)); System.out.println(set2); // Set--&gt;数组 Set&lt;String&gt; set3 = new HashSet&lt;String&gt;(Arrays.asList("PP", "OO")); String[] strSet = new String[set3.size()]; set3.toArray(strSet); System.out.println(Arrays.toString(strSet)); // Map操作 Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put("YYY", "UUU"); map.put("RRR", "TTT"); // 将键转化为Set Set&lt;String&gt; mapKeySet = map.keySet(); // 将值转化为Set Set&lt;String&gt; mapValuesSet = new HashSet&lt;String&gt;(map.values()); // 将值转化为List List&lt;String&gt; mapValuesList = new ArrayList&lt;String&gt;(map.values()); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[curl命令使用指南]]></title>
      <url>%2F2016%2F11%2F29%2Fcurl-command-usage-guide%2F</url>
      <content type="text"><![CDATA[我一向以为，curl只是一个编程用的函数库。最近才发现，这个命令本身，就是一个无比有用的网站开发工具，请看我整理的它的用法。curl是一种命令行工具，作用是发出网络请求，然后得到和提取数据，显示在”标准输出”（stdout）上面。 curl的选项功能1234567891011121314151617181920212223242526不带任何参数时curl将返回指定url中的数据并打印在屏幕上 -u 使用用户名和密码登陆。如curl -uname:passwd URL -b/--cookie &lt;name=data&gt; 向服务器提交cookie，若无=则name视为文件名，例如：curl -b cookie.txt www.imarkofu.com -o out 将指定curl返回保存为out文件，内容从html/jpg到各种MIME类型文件。如curl -o page.html URL -d &lt;key=value&gt; 向服务器POST表单数据 例如：curl -d &quot;pageSize=8&amp;pageNo=5&quot; http://www.imarkofu.com/load.do -A/--user-agent &lt;ua&gt; 指定发送请求的用户代理，例如：curl -A My-Agent/1.0.0 www.imarkofu.com -x ip:port 指定使用的http代理，例如：curl -x 192.168.1.1:8080 www.imarkofu.com -D head.txt 将服务器的返回的header保存为文件，头部的cookie也可被保存，例如：curl -D header.txt www.imarkofu.com -L 当页面有跳转的时候，输出跳转到的页面 -I header信息 当有跳转时，可以通过 curl -L -I URL|grep Location 来确定跳转到的新url地址 -c &lt;file&gt; 保存服务器的cookie文件 -e url 设置引用头的值 -T localfile 向服务器PUT文件 例如：curl -T xxx.doc www.imarkofu.com/upload.do -F &lt;key=value&gt; 向服务器POST表单，例如：curl -F &quot;web=@index.html;type=text/html&quot; url.com -E cert.pem 指定本地证书 -H &lt;header:value&gt; 为HTTP请求设置任意header及值。如curl -H &quot;Connection:keep-alive&quot; http://www.imarkofu.com -X/--request method 用户定义的HTTP请求方法名如 curl -X GET www.imarkofu.com -compressed 采用压缩方式接收返回数据 -connect-timeout `&lt;`s`&gt;` 设置超时时间 -v 详细输出，包含请求和响应的首部 --retry num --retry timeo 指定重试的次数和间隔 --tcp-nodelay 打开TCP_NODELAY选项 不进行捎带确认 -O 按服务器上的名称保存下载的文件 -r/--range from-to 下载指定range内的数据 -C 在保存文件时进行续传 curl的常见使用curl查看web站点rt123456789101112131415161718curl -o /dev/null -s -w %&#123;time_namelookup&#125;::%&#123;time_connect&#125;::%&#123;time_starttransfer&#125;::%&#123;time_total&#125;::%&#123;speed_download&#125;&quot;\n&quot; &quot;http://www.taobao.com&quot; 0.014::0.015::0.018::0.019::1516256.00 -s：去掉所有状态 -w：按照后面的格式写出rttime_namelookup：DNS 解析域名[www.taobao.com]的时间 time_commect：client和server端建立TCP 连接的时间time_starttransfer：从client发出请求；到web的server 响应第一个字节的时间time_total：client发出请求；到web的server发送会所有的相应数据的时间speed_download：下载速度 单位 byte/s0.014: DNS 服务器解析www.taobao.com 的时间单位是s0.015: client发出请求到server建立TCP的时间，里面包括DNS解析的时间 0.018: client发出请求到server响应发出第一个字节开始的时间，包括前面的2个时间 0.019: client发出请求到server把响应的数据全部发送给client,并关闭connect的时间 1516256.00 ：下载数据的速度 1. 建立TCP连接到server返回client第一个字节的时间：0.018s - 0.015s = 0.003s 2. server把响应数据发送给client的时间：0.019s - 0.018 = 0.01s]]></content>
    </entry>

    
  
  
</search>
