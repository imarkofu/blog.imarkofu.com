<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[mysql字符函数详解]]></title>
      <url>%2F2016%2F12%2F29%2Fmysql-function%2F</url>
      <content type="text"><![CDATA[ASCII(str)返回字符串str的最左面字符的ASCII代码值。如果str是空字符串，返回0。如果str是NULL，返回NULL。 123456789101112131415161718mysql&gt; select ASCII(&apos;4&apos;);+------------+| ASCII(&apos;4&apos;) |+------------+| 52 |+------------+mysql&gt; select ASCII(4);+----------+| ASCII(4) |+----------+| 52 |+----------+mysql&gt; select ASCII(&apos;dx&apos;);+-------------+| ASCII(&apos;ex&apos;) |+-------------+| 101 |+-------------+ 也可参见ORD()函数。ORD(str) 如果字符串str最左面字符是一个多字节字符，通过以格式((first byte ASCII code)256+(second byte ASCII code))[256+third byte ASCII code…]返回字符的ASCII代码值来返回多字节字符代码。如果最左面的字符不是一个多字节字符。返回与ASCII()函数返回的相同值。123456mysql&gt; select ORD(&apos;3&apos;);+----------+| ORD(&apos;3&apos;) |+----------+| 51 |+----------+ CONV(N,from_base,to_base)在不同的数字基之间变换数字。返回数字N的字符串数字，从from_base基变换为to_base基，如果任何参数是NULL，返回NULL。参数N解释为一个整数，但是可以指定为一个整数或一个字符串。最小基是2且最大的基是36。如果to_base是一个负数，N被认为是一个有符号数，否则，N被当作无符号数。 CONV以64位点精度工作。123456789101112131415161718192021222324mysql&gt; select CONV(&quot;A&quot;,16,2);+----------------+| CONV(&quot;A&quot;,16,2) |+----------------+| 1010 |+----------------+mysql&gt; select CONV(&quot;6EB&quot;,18,8);+------------------+| CONV(&quot;6EB&quot;,18,8) |+------------------+| 4237 |+------------------+mysql&gt; select CONV(-178,10,-18);+-------------------+| CONV(-178,10,-18) |+-------------------+| -9G |+-------------------+mysql&gt; select CONV(10+&quot;10&quot;+&apos;10&apos;+0xB,10,10);+------------------------------+| CONV(10+&quot;10&quot;+&apos;10&apos;+0xB,10,10) |+------------------------------+| 41 |+------------------------------+ BIN(N) 返回二进制值N的一个字符串表示，在此N是一个长整数(BIGINT)数字，这等价于CONV(N,10,2)。如果N是NULL，返回NULL。123456mysql&gt; select BIN(532);+------------+| BIN(532) |+------------+| 1000010100 |+------------+ OCT(N)返回八进制值N的一个字符串的表示，在此N是一个长整型数字，这等价于CONV(N,10,8)。如果N是NULL，返回NULL。123456mysql&gt; select OCT(98);+---------+| OCT(98) |+---------+| 142 |+---------+ HEX(N)返回十六进制值N一个字符串的表示，在此N是一个长整型(BIGINT)数字，这等价于CONV(N,10,16)。如果N是NULL，返回NULL。123456mysql&gt; select HEX(432);+----------+| HEX(432) |+----------+| 1B0 |+----------+ CHAR(N,…)CHAR()将参数解释为整数并且返回由这些整数的ASCII代码字符组成的一个字符串。NULL值被跳过。123456789101112mysql&gt; select CHAR(77, 121, 83, 81,&apos;76&apos;);+----------------------------+| CHAR(77, 121, 83, 81,&apos;76&apos;) |+----------------------------+| MySQL |+----------------------------+mysql&gt; select CHAR(77,77.3,&apos;77.3&apos;);+----------------------+| CHAR(77,77.3,&apos;77.3&apos;) |+----------------------+| MMM |+----------------------+ CONCAT(str1,str2,…)返回来自于参数连结的字符串。如果任何参数是NULL，返回NULL。可以有超过2个的参数。一个数字参数被变换为等价的字符串形式。123456789101112131415161718mysql&gt; select CONCAT(&apos;My&apos;, &apos;S&apos;, &apos;QL&apos;);+-------------------------+| CONCAT(&apos;My&apos;, &apos;S&apos;, &apos;QL&apos;) |+-------------------------+| MySQL |+-------------------------+mysql&gt; select CONCAT(&apos;My&apos;, NULL, &apos;QL&apos;);+--------------------------+| CONCAT(&apos;My&apos;, NULL, &apos;QL&apos;) |+--------------------------+| NULL |+--------------------------+mysql&gt; select CONCAT(14.3);+--------------+| CONCAT(14.3) |+--------------+| 14.3 |+--------------+ LENGTH(str)、OCTET_LENGTH(str)、CHAR_LENGTH(str)、CHARACTER_LENGTH(str)返回字符串str的长度。12345678910111213mysql&gt; select LENGTH(&apos;hello world&apos;);+-----------------------+| LENGTH(&apos;hello world&apos;) |+-----------------------+| 11 |+-----------------------+mysql&gt; select OCTET_LENGTH(&apos;hello world&apos;);+-----------------------------+| OCTET_LENGTH(&apos;hello world&apos;) |+-----------------------------+| 11 |+-----------------------------+注意，对于多字节字符，其CHAR_LENGTH()仅计算一次。 LOCATE(substr,str,pos)、POSITION(substr IN str)返回子串substr在字符串str第一个出现的位置，如果substr不是在str里面，返回0如果设置了pos值，那么起始位置将从pos处，否则从1开始。12345678910111213mysql&gt; select LOCATE(&apos;bar&apos;, &apos;foobarbar&apos;);+----------------------------+| LOCATE(&apos;bar&apos;, &apos;foobarbar&apos;) |+----------------------------+| 4 |+----------------------------+mysql&gt; select LOCATE(&apos;bar&apos;, &apos;foobarbar&apos;, 5);+-------------------------------+| LOCATE(&apos;bar&apos;, &apos;foobarbar&apos;, 5) |+-------------------------------+| 7 |+-------------------------------+这函数是多字节可靠的。 INSTR(str,substr)返回子串substr在字符串str中的第一个出现的位置。这与有2个参数形式的LOCATE()相同，除了参数被颠倒。1234567mysql&gt; select INSTR(&apos;foobarbar&apos;, &apos;bar&apos;);+---------------------------+| INSTR(&apos;foobarbar&apos;, &apos;bar&apos;) |+---------------------------+| 4 |+---------------------------+这函数是多字节可靠的。 LPAD(str,len,padstr)返回字符串str，左面用字符串padstr填补直到str是len个字符长。123456mysql&gt; select LPAD(&apos;A&apos;,5,&apos;BCD&apos;);+-------------------+| LPAD(&apos;A&apos;,5,&apos;BCD&apos;) |+-------------------+| BCDBA |+-------------------+ RPAD(str,len,padstr)返回字符串str，右面用字符串padstr填补直到str是len个字符长。123456mysql&gt; select RPAD(&apos;A&apos;,5,&apos;BCD&apos;);+-------------------+| RPAD(&apos;A&apos;,5,&apos;BCD&apos;) |+-------------------+| ABCDB |+-------------------+ LEFT(str,len)返回字符串str的最左面len个字符。1234567mysql&gt; select LEFT(&apos;hello world&apos;, 7);+------------------------+| LEFT(&apos;hello world&apos;, 7) |+------------------------+| hello w |+------------------------+该函数是多字节可靠的。 RIGHT(str,len)返回字符串str的最右面len个字符。1234567mysql&gt; select RIGHT(&apos;hello world&apos;, 7); +-------------------------+| RIGHT(&apos;hello world&apos;, 7) |+-------------------------+| o world |+-------------------------+该函数是多字节可靠的。 SUBSTRING(str,pos,len)、SUBSTRING(str FROM pos FOR len)、MID(str,pos,len)从字符串str返回一个len个字符的子串，从位置pos开始。使用FROM的变种形式是ANSI SQL92语法。1234567mysql&gt; select SUBSTRING(&apos;abcdefghijk&apos;,5,6); +------------------------------+| SUBSTRING(&apos;abcdefghijk&apos;,5,6) |+------------------------------+| efghij |+------------------------------+该函数是多字节可靠的。 SUBSTRING(str,pos)、SUBSTRING(str FROM pos)从字符串str的起始位置pos返回一个子串。1234567mysql&gt; select SUBSTRING(&apos;abcdefghijk&apos;,5); +----------------------------+| SUBSTRING(&apos;abcdefghijk&apos;,5) |+----------------------------+| efghijk |+----------------------------+该函数是多字节可靠的。 SUBSTRING_INDEX(str,delim,count)返回从字符串str的第count个出现的分隔符delim之后的子串。如果count是正数，返回最后的分隔符到左边(从左边数) 的所有字符。如果count是负数，返回最后的分隔符到右边的所有字符(从右边数)。1234567mysql&gt; select SUBSTRING_INDEX(&apos;http://blog.imarkofu.com&apos;, &apos;.&apos;, 2); +-----------------------------------------------------+| SUBSTRING_INDEX(&apos;http://blog.imarkofu.com&apos;, &apos;.&apos;, 2) |+-----------------------------------------------------+| http://blog.imarkofu |+-----------------------------------------------------+该函数对多字节是可靠的。 LTRIM(str)返回删除了其前置空格字符的字符串str。123456mysql&gt; select LTRIM(&apos; hello world &apos;); +----------------------------+| LTRIM(&apos; hello world &apos;) |+----------------------------+| hello world |+----------------------------+ RTRIM(str)返回删除了其拖后空格字符的字符串str。123456mysql&gt; select RTRIM(&apos; hello world &apos;); +----------------------------+| RTRIM(&apos; hello world &apos;) |+----------------------------+| hello world |+----------------------------+ TRIM([[BOTH | LEADING | TRAILING] [remstr] FROM] str)返回字符串str，其所有remstr前缀或后缀被删除了。如果没有修饰符BOTH、LEADING或TRAILING给出，BOTH被假定。如果remstr没被指定，空格被删除。12345678910111213141516171819202122232425mysql&gt; select TRIM(&apos; hello world &apos;); +---------------------------+| TRIM(&apos; hello world &apos;) |+---------------------------+| hello world |+---------------------------+mysql&gt; select TRIM(LEADING &apos;x&apos; FROM &apos;xxxbarxxx&apos;);+------------------------------------+| TRIM(LEADING &apos;x&apos; FROM &apos;xxxbarxxx&apos;) |+------------------------------------+| barxxx |+------------------------------------+mysql&gt; select TRIM(TRAILING &apos;x&apos; FROM &apos;xxxbarxxx&apos;); +-------------------------------------+| TRIM(TRAILING &apos;x&apos; FROM &apos;xxxbarxxx&apos;) |+-------------------------------------+| xxxbar |+-------------------------------------+mysql&gt; select TRIM(BOTH &apos;x&apos; FROM &apos;xxxbarxxx&apos;); +---------------------------------+| TRIM(BOTH &apos;x&apos; FROM &apos;xxxbarxxx&apos;) |+---------------------------------+| bar |+---------------------------------+该函数对多字节是可靠的。 SOUNDEX(str)返回str的一个同音字符串。听起来“大致相同”的2个字符串应该有相同的同音字符串。一个“标准”的同音字符串长是4个字符，但是SOUNDEX()函数返回一个任意长的字符串。你可以在结果上使用SUBSTRING()得到一个“标准”的 同音串。所有非数字字母字符在给定的字符串中被忽略。所有在A-Z之外的字符国际字母被当作元音。123456mysql&gt; select SOUNDEX(&apos;Hello&apos;);+------------------+| SOUNDEX(&apos;Hello&apos;) |+------------------+| H400 |+------------------+ SPACE(N)返回由N个空格字符组成的一个字符串。123456mysql&gt; select SPACE(32);+----------------------------------+| SPACE(32) |+----------------------------------+| |+----------------------------------+ REPLACE(str,from_str,to_str)返回字符串str，其字符串from_str的所有出现由字符串to_str代替。123456mysql&gt; select REPLACE(&apos;www.mysql.com&apos;, &apos;w&apos;, &apos;M&apos;); +------------------------------------+| REPLACE(&apos;www.mysql.com&apos;, &apos;w&apos;, &apos;M&apos;) |+------------------------------------+| MMM.mysql.com |+------------------------------------+ REPEAT(str,count)返回由重复countTimes次的字符串str组成的一个字符串。如果count &lt;= 0，返回一个空字符串。如果str或count是NULL，返回NULL。123456mysql&gt; select REPEAT(&apos;MySQL&apos;, 3);+--------------------+| REPEAT(&apos;MySQL&apos;, 3) |+--------------------+| MySQLMySQLMySQL |+--------------------+ REVERSE(str)返回颠倒字符顺序的字符串str。123456mysql&gt; select REVERSE(&apos;abc&apos;);+----------------+| REVERSE(&apos;abc&apos;) |+----------------+| cba |+----------------+ INSERT(str,pos,len,newstr)返回字符串str，在位置pos起始的子串且len个字符长得子串由字符串newstr代替。123456mysql&gt; select INSERT(&apos;Quadratic&apos;, 3, 5, &apos;What&apos;); +-----------------------------------+| INSERT(&apos;Quadratic&apos;, 3, 5, &apos;What&apos;) |+-----------------------------------+| QuWhatic |+-----------------------------------+ ELT(N,str1,str2,str3,…)如果N= 1，返回str1，如果N= 2，返回str2，等等。如果N小于1或大于参数个数，返回NULL。ELT()是FIELD()反运算。123456mysql&gt; select ELT(1, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;); +----------------------------+| ELT(1, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;) |+----------------------------+| A |+----------------------------+ FIELD(str,str1,str2,str3,…)返回str在str1, str2, str3, …清单的索引。如果str没找到，返回0。FIELD()是ELT()反运算。123456mysql&gt; select FIELD(&apos;F&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;EF&apos;);+--------------------------------------+| FIELD(&apos;F&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;EF&apos;) |+--------------------------------------+| 0 |+--------------------------------------+ FIND_IN_SET(str,strlist)如果字符串str在由N子串组成的表strlist之中，返回一个1到N的值。一个字符串表是被“,”分隔的子串组成的一个字符串。如果第一个参数是一个常数字符串并且第二个参数是一种类型为SET的列，FIND_IN_SET()函数被优化而使用位运算！如果str不是在strlist里面或如果strlist是空字符串，返回0。如果任何一个参数是NULL，返回NULL。如果第一个参数包含一个“,”，该函数将工作不正常。123456mysql&gt; SELECT FIND_IN_SET(&apos;C&apos;,&apos;A,B,C,D&apos;);+----------------------------+| FIND_IN_SET(&apos;C&apos;,&apos;A,B,C,D&apos;) |+----------------------------+| 3 |+----------------------------+ MAKE_SET(bits,str1,str2,…)返回一个集合 (包含由“,”字符分隔的子串组成的一个字符串)，由相应的位在bits集合中的的字符串组成。str1对应于位0，str2对应位1，等等。在str1, str2, …中的NULL串不添加到结果中。123456789101112mysql&gt; SELECT MAKE_SET(4,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;);+-------------------------+| MAKE_SET(4,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;) |+-------------------------+| c |+-------------------------+mysql&gt; SELECT MAKE_SET(1|4,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;);+---------------------------+| MAKE_SET(1|4,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;) |+---------------------------+| a,c |+---------------------------+ EXPORT_SET(bits,on,off,[separator,[number_of_bits]])返回一个字符串，在这里对于在“bits”中设定每一位，你得到一个“on”字符串，并且对于每个复位(reset)的位，你得到一个“off”字符串。每个字符串用“separator”分隔(缺省“,”)，并且只有“bits”的“number_of_bits” (缺省64)位被使用。123456mysql&gt; select EXPORT_SET(7,&apos;Y&apos;,&apos;N&apos;,&apos;,&apos;,6);+-----------------------------+| EXPORT_SET(7,&apos;Y&apos;,&apos;N&apos;,&apos;,&apos;,6) |+-----------------------------+| Y,Y,Y,N,N,N |+-----------------------------+ LCASE(str)、LOWER(str)返回字符串str，根据当前字符集映射(缺省是ISO-8859-1 Latin1)把所有的字符改变成小写。该函数对多字节是可靠的。123456mysql&gt; select LOWER(&apos;Imarkofu&apos;); +-------------------+| LOWER(&apos;Imarkofu&apos;) |+-------------------+| imarkofu |+-------------------+ UCASE(str)、UPPER(str)返回字符串str，根据当前字符集映射(缺省是ISO-8859-1 Latin1)把所有的字符改变成大写。该函数对多字节是可靠的。123456mysql&gt; select UPPER(&apos;Imarkofu&apos;);+-------------------+| UPPER(&apos;Imarkofu&apos;) |+-------------------+| IMARKOFU |+-------------------+ LOAD_FILE(file_name)读入文件并且作为一个字符串返回文件内容。文件必须在服务器上，你必须指定到文件的完整路径名，而且你必须有file权限。文件必须所有内容都是可读的并且小于max_allowed_packet。如果文件不存在或由于上面原因之一不能被读出，函数返回NULL。1234567mysql&gt; select load_file(&quot;/abc.txt&quot;); +-----------------------+| load_file(&quot;/abc.txt&quot;) |+-----------------------+| ABC |+-----------------------+ MySQL必要时自动变换数字为字符串，并且反过来也如此：123456789101112mysql&gt; SELECT 3+&quot;2&quot;;+-------+| 3+&quot;2&quot; |+-------+| 5 |+-------+mysql&gt; SELECT CONCAT(3+&quot;2&quot;,&apos; total&apos;);+------------------------+| CONCAT(3+&quot;2&quot;,&apos; total&apos;) |+------------------------+| 5 total |+------------------------+ 如果你想要明确地变换一个数字到一个字符串，把它作为参数传递到CONCAT()。如果字符串函数提供一个二进制字符串作为参数，结果字符串也是一个二进制字符串。被变换到一个字符串的数字被当作是一个二进制字符串。这仅影响比较;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux date命令]]></title>
      <url>%2F2016%2F12%2F29%2Flinux-date-command%2F</url>
      <content type="text"><![CDATA[date命令是显示或设置系统时间与日期。很多shell脚本里面需要打印不同格式的时间或日期，以及要根据时间和日期执行操作。延时通常用于脚本执行过程中提供一段等待的时间。日期可以以多种格式去打印，也可以使用命令设置固定的格式。在类UNIX系统中，日期被存储为一个整数，其大小为自世界标准时间（UTC）1970年1月1日0时0分0秒起流逝的秒数。 选项 -d&lt;字符串&gt;：显示字符串所指的日期与时间。字符串前后必须加上双引号；-s&lt;字符串&gt;：根据字符串来设置日期与时间。字符串前后必须加上双引号；-u：显示GMT； 参数 &lt;+时间日期格式&gt;：指定显示时使用的日期时间格式。 日期格式字符串列表 %H 小时，24小时制（00~23）%I 小时，12小时制（01~12）%k 小时，24小时制（0~23）%l 小时，12小时制（1~12）%M 分钟（00~59）%p 显示出AM或PM%r 显示时间，12小时制（hh:mm:ss %p）%s 从1970年1月1日00:00:00到目前经历的秒数%S 显示秒（00~59）%T 显示时间，24小时制（hh:mm:ss）%X 显示时间的格式（%H:%M:%S）%Z 显示时区，日期域（CST）%a 星期的简称（Sun~Sat）%A 星期的全称（Sunday~Saturday）%h,%b 月的简称（Jan~Dec）%B 月的全称（January~December）%c 日期和时间（Tue Nov 20 14:12:58 2012）%d 一个月的第几天（01~31）%x,%D 日期（mm/dd/yy）%j 一年的第几天（001~366）%m 月份（01~12）%w 一个星期的第几天（0代表星期天）%W 一年的第几个星期（00~53，星期一为第一天）%y 年的最后两个数字（1999则是99） 实例格式化输出 date +”%Y-%m-%d”2016-12-29 输出昨天日期： date -d “1 day ago” +”%Y-%m-%d”2016-12-28 2秒后输出： date -d “2 second” +”%Y-%m-%d %H:%M.%S”2016-12-29 14:37.22 传说中的 1234567890 秒： date -d “1970-01-01 1482990408 seconds” +”%Y-%m-%d %H:%m:%S”2016-12-29 05:12:48 普通转格式： date -d “2016-12-29” +”%Y/%m/%d %H:%M.%S”2016/12/29 00:00.00 apache格式转换： date -d “Dec 29, 2016 12:00:37 AM” +”%Y-%m-%d %H:%M.%S”2016-12-29 00:00.37 格式转换后时间游走： date -d “Dec 29, 2016 12:00:37 AM 2 year ago” +”%Y-%m-%d %H:%M.%S”2014-12-29 00:00.37 加减操作： date -s //设置当前时间，只有root权限才能设置，其他只能查看date -s 20161229 //设置成20120523，这样会把具体时间设置成空00:00:00date -s 01:01:01 //设置具体时间，不会对日期做更改date -s “01:01:01 2016-12-29” //这样可以设置全部时间date -s “01:01:01 20161229” //这样可以设置全部时间date -s “2016-12-29 01:01:01” //这样可以设置全部时间date -s “20161229 01:01:01” //这样可以设置全部时间]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SVN备份方案]]></title>
      <url>%2F2016%2F12%2F01%2Fsvn-backup%2F</url>
      <content type="text"><![CDATA[备份策略svn备份一般采用三种方式： 1）svnadmin dump2)svnadmin hotcopy3)svnsync 注意：svn备份不宜采用普通的文件拷贝方式（除非你备份的时候将库暂停），如copy命令、rsync命令。 优缺点分析第一种svnadmin dump是官方推荐的备份方式，优点是比较灵活，可以全量备份也可以增量备份，并提供了版本恢复机制。缺点是：如果版本比较大，如版本数增长到数万、数十万，那么dump的过程将非常慢；备份耗时，恢复更耗时；不利于快速进行灾难恢复。个人建议在版本数比较小的情况下使用这种备份方式。第二种svnadmin hotcopy原设计目的估计不是用来备份的，只能进行全量拷贝，不能进行增量备份；优点是：备份过程较快，灾难恢复也很快；如果备份机上已经搭建了svn服务，甚至不需要恢复，只需要进行简单配置即可切换到备份库上工作。缺点是：比较耗费硬盘，需要有较大的硬盘支持（俺的备份机有1TB空间，呵呵）。第三种svnsync实际上是制作2个镜像库，当一个坏了的时候，可以迅速切换到另一个。不过，必须svn1.4版本以上才支持这个功能。优点是：当制作成2个镜像库的时候起到双机实时备份的作用；缺点是：当作为2个镜像库使用时，没办法做到“想完全抛弃今天的修改恢复到昨晚的样子”；而当作为普通备份机制每日备份时，操作又较前2种方法麻烦。 备份方案以下是个人的备份方案：1、定期对线上SVN进行全量备份【目前每月1号】svnadmin dump /仓库路径/仓库名 |gzip &gt; ~/svn/仓库名_yyyyMMdd.gz将备份文件统一上传到其他设备的备份目录下进行存档 2、定期进行全量备份恢复测试解压.gz文件建立新的svn仓库导入存储库 svnadmin load 仓库路径 &lt; 解压的备份文件 3、对常用的几个SVN仓库进行热备份首先在其他设备上上编译安装SVN创建需要备份的仓库（这里以sm为例） svnadmin create 从仓库路径cp /从仓库路径/hooks/pre-revprop-change.tmpl /从仓库路径/hooks/pre-revprop-change 修改/从仓库路径/hooks/pre-revprop-change的内容，将最后的”exit 1”修改”exit 0”增加执行权限将主svn的对应仓库目录下的所有配置文件拷贝到从svn的仓库目录下覆盖替换 在从SVN上执行如下命令，进行初始化【这里尚未开始进行同步】 svnsync init 从仓库地址 主仓库地址svnsync init file:///从仓库路径 主仓库地址注意这里是三个/ 这里会询问当前Linux用户的密码，主SVN用户名，主SVN密码输入相应即可，然后会询问是否明文存储【这里建议输入no不存在，每次自行输入】 开始同步数据 svnsync sync file:///从仓库路径这里如果又用户正在提交SVN时，可能会出现获取锁失败的问题，需要清除锁的命令，再继续同步svn propdel svn:sync-lock –revprop -r0 file:///从仓库路径 同步完成之后，为了保证后续的SVN更新都能自动同步到从svn中需要在主SVN的/仓库路径/hooks下建立post-commit脚本，增加如下内容 svnsync sync –non-interactive 从仓库地址 –username 用户名 –password 密码 至此双击热备份即完成，可能还需要做的是定期抽查热备是否正常；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[windows server 2008 R2忘记administrator密码]]></title>
      <url>%2F2016%2F11%2F30%2Fwindows-forgets-the-administrator-password%2F</url>
      <content type="text"><![CDATA[对于一个专业的运维人员而言，可能收下有很多台设备需要管理，这里不免需要记录各种奇奇怪怪的密码，可能发生最北催的事情，莫过于忘记了自己维护设备的管理密码。忘记密码其实还是有解决方案的，只需要拿到一张系统的安装光盘。将光盘放入光驱当中，重启电脑，从光驱启动电脑，在选择“安装语言”的位置，按Shite+F10此时会弹出一个dos窗口，在这个dos窗口中执行如下命令1234cd windows\system32ren Magnify.exe Magnify1.exeren cmd.exe Magnify.exeexit 以上命令主要是用于替换掉放大镜窗口然后再次重启电脑，正常启动在需要输入密码的界面中，点击放大镜，打开放大镜会出现一个dos窗口，这就是我们上面的操作的目的然后执行如下命令1net user administrator Imarkofu123456 注：这里的Imarkofu123456即为重置的新密码，你可以根据自己的情况设置密码还有一点需要注意的是设置密码时不要使用特殊字符，只要数字大小写字母就可以了然后关闭窗口输入刚刚重置的密码即可登录了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CentOS 6.5安全加固及性能优化]]></title>
      <url>%2F2016%2F11%2F30%2Fcentos-safety-reinforcement-and-performance-optimization%2F</url>
      <content type="text"><![CDATA[说明：经常玩Linux系统的朋友多多少少也知道些系统参数优化和怎样增强系统安全性，系统默认的一些参数都是比较保守的，所以我们可以通过调整系统参数来提高系统内存、CPU、内核资源的占用，通过禁用不必要的服务、端口，来提高系统的安全性，更好的发挥系统的可用性。通过自己对Linux了解，对系统调优做了如下小结：操作系统：CentOS 6.5_x64最小化安装 1、主机名设置123[root@localhost~]# vi /etc/sysconfig/networkHOSTNAME=test.com[root@localhost~]# hostname test.com #临时生效 2、关闭SELinux1234[root@localhost~]# vi /etc/selinux/configSELINUX=disabled[root@localhost~]# setenforce #临时生效[root@localhost~]# getenforce #查看selinux状态 3、清空防火墙并设置规则12345678910[root@localhost~]# iptables -F #清楚防火墙规则[root@localhost~]# iptables -L #查看防火墙规则[root@localhost~]# iptables -A INPUT -p tcp --dport 80 -j ACCEPT[root@localhost~]# iptables -A INPUT -p tcp --dport 22 -j ACCEPT[root@localhost~]# iptables -A INPUT -p tcp --dport 53 -j ACCEPT[root@localhost~]# iptables -A INPUT -p udp --dport 53 -j ACCEPT[root@localhost~]# iptables -A INPUT -p udp --dport 123 -j ACCEPT[root@localhost~]# iptables -A INPUT -p icmp -j ACCEPT[root@localhost~]# iptables -P INPUT DROP[root@localhost~]# /etc/init.d/iptables save 根据需求开启相应端口 4、添加普通用户并进行sudo授权管理12345[root@localhost~]# useradd user[root@localhost~]# echo &quot;123456&quot; | passwd --stdin user #设置密码[root@localhost~]# vi /etc/sudoers #或visudo打开，添加user用户所有权限root ALL=(ALL) ALLuser ALL=(ALL) ALL 5、禁用root远程登录1234[root@localhost~]# vi /etc/ssh/sshd_configPermitRootLogin noPermitEmptyPasswords no #禁止空密码登录UseDNS no #关闭DNS查询 6、关闭不必要开机自启动服务12345678910111213[root@localhost~]# chkconfig auditd off[root@localhost~]# chkconfig blk-availablility off[root@localhost~]# chkconfig ip6tables off[root@localhost~]# chkconfig lvm2-monitor off[root@localhost~]# chkconfig netfs off[root@localhost~]# chkconfig udev-post off[root@localhost~]# chkconfig --list | grep 3:oncrond 0:off 1:off 2:on 3:on 4:on 5:on 6:offnetwork 0:off 1:off 2:on 3:on 4:on 5:on 6:offpostfix 0:off 1:off 2:on 3:on 4:on 5:on 6:offrsyslog 0:off 1:off 2:on 3:on 4:on 5:on 6:offsshd 0:off 1:off 2:on 3:on 4:on 5:on 6:off[root@localhost~]# 7、删除不必要的系统用户1234567891011121314151617181920212223242526272829[root@localhost~]# awk -F&quot;:&quot; &apos;&#123;print $1&#125;&apos; /etc/passwdrootbindaemonadmlpsyncshutdownhaltmailuucpoperatorgamesgopherftpnobodyvcsasaslauthpostfixsshdntp[root@localhost~]# userdel adm[root@localhost~]# userdel lp[root@localhost~]# userdel shutdown[root@localhost~]# userdel halt[root@localhost~]# userdel uucp[root@localhost~]# userdel operator[root@localhost~]# userdel games[root@localhost~]# userdel gopher 8、关闭重启ctl-alt-delete组合键12[root@localhost ~]# vi /etc/init/control-alt-delete.conf#exec /sbin/shutdown -r now &quot;Control-Alt-Deletepressed&quot; #注释掉 9、调整文件描述符大小123[root@localhost ~]# ulimit –n #默认是10241024[root@localhost ~]# echo &quot;ulimit -SHn 102400&quot;&gt;&gt; /etc/rc.local #设置开机自动生效 11、修改history记录12[root@localhost ~]# vi /etc/profile #修改记录10个HISTSIZE=10 12、同步系统时间1234[root@localhost ~]# cp /usr/share/zoneinfo/Asia/Shanghai/etc/localtime #设置Shanghai时区[root@localhost ~]# ntpdate cn.pool.ntp.org ；hwclock–w #同步时间并写入blos硬件时间[root@localhost ~]# crontab –e #设置任务计划每天零点同步一次0 0 * * * /usr/sbin/ntpdate cn.pool.ntp.org ; hwclock -w 13、内核参数优化123456789101112131415161718192021[root@localhost ~]# vi /etc/sysctl.conf #末尾添加如下参数net.ipv4.tcp_syncookies = 1 #1是开启SYN Cookies，当出现SYN等待队列溢出时，启用Cookies来处，理，可防范少量SYN攻击，默认是0关闭net.ipv4.tcp_tw_reuse = 1 #1是开启重用，允许讲TIME_AIT sockets重新用于新的TCP连接，默认是0关闭net.ipv4.tcp_tw_recycle = 1 #TCP失败重传次数，默认是15，减少次数可释放内核资源net.ipv4.ip_local_port_range = 4096 65000 #应用程序可使用的端口范围net.ipv4.tcp_max_tw_buckets = 5000 #系统同时保持TIME_WAIT套接字的最大数量，如果超出这个数字，TIME_WATI套接字将立刻被清除并打印警告信息，默认180000net.ipv4.tcp_max_syn_backlog = 4096 #进入SYN宝的最大请求队列，默认是1024net.core.netdev_max_backlog = 10240 #允许送到队列的数据包最大设备队列，默认300net.core.somaxconn = 2048 #listen挂起请求的最大数量，默认128net.core.wmem_default = 8388608 #发送缓存区大小的缺省值net.core.rmem_default = 8388608 #接受套接字缓冲区大小的缺省值（以字节为单位）net.core.rmem_max = 16777216 #最大接收缓冲区大小的最大值net.core.wmem_max = 16777216 #发送缓冲区大小的最大值net.ipv4.tcp_synack_retries = 2 #SYN-ACK握手状态重试次数，默认5net.ipv4.tcp_syn_retries = 2 #向外SYN握手重试次数，默认4net.ipv4.tcp_tw_recycle = 1 #开启TCP连接中TIME_WAIT sockets的快速回收，默认是0关闭net.ipv4.tcp_max_orphans = 3276800 #系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上，如果超出这个数字，孤儿连接将立即复位并打印警告信息net.ipv4.tcp_mem = 94500000 915000000 927000000net.ipv4.tcp_mem[0]:低于此值，TCP没有内存压力；net.ipv4.tcp_mem[1]:在此值下，进入内存压力阶段；net.ipv4.tcp_mem[2]:高于此值，TCP拒绝分配socket。内存单位是页，可根据物理内存大小进行调整，如果内存足够大的话，可适当往上调。上述内存单位是页，而不是字节。 至此CentOS 6.5_x64最小化安装系统基本优化调整完毕，需要重启下系统。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[centos 6.5 编译安装 mysql 5.5.40]]></title>
      <url>%2F2016%2F11%2F30%2Fcentos-compile-and-install-MySQL%2F</url>
      <content type="text"><![CDATA[在开始之前我们需要准备一些库文件。1[root@imarkofu ~]# yum install zlib-devel openssl-devel gcc-c++ gcc bison cmake ncurses-devel -y 一定要安装这些包， LZ之前没有安装就开始编译MySQL，踩了好多坑， 后来上网一查才发现需要这些文件和管理工具才行。因此一定要安装。还有如果大家编译过程中出错, 请一定要执行:1[root@imarkofu ~]# rm -f CMakeCache.txt 之后再继续安装。安装好之后我们来添加MySQL数据库需要的账户和目录：12345[root@imarkofu ~]# groupadd -r mysql[root@imarkofu ~]# useradd -g mysql -r -s /sbin/nologin mysql[root@imarkofu ~]# id mysql #确认用户[root@imarkofu ~]# mkdir /var/data/mysql -p #存放数据库文件[root@imarkofu ~]# chown mysql:mysql /var/data -R 下载MySQL源码包：mysql-5.5.40.tar.gz下载后上传到服务器12[root@imarkofu ~]# tar -xvf mysql-5.5.40.tar.gz -C /usr/local/src/[root@imarkofu ~]# cd /usr/local/src/mysql-5.5.40 cmake编译MySQL的一些常用选项：12345678910111213141516171819202122232425262728293031323334353637------------------------------------------------------------cmake mysql 编译安装:./configure -&gt; cmake ../configure --help -&gt; cmake -LH -&gt; ccmake .------------------------------------------------------------指定安装文件的安装路径常用选项-DCMAKE_INSTALL_PREFIX=/usr/local/mysql-DMYSQL_DATADIR=/data/mysql-DSYSCONFDIR=/etc------------------------------------------------------------默认编译的存储引擎包括: csv, myisma, myisammrg, heap. 若要安装其他存储引擎,可以使用类似如下的编译选项-DWITH_INNOBASE_STORAGE_ENGINE=1-DWITH_ARCHIVE_STORAGE_ENGINE=1-DWITH_BLACKHOLE_STORAGE_ENGINE=1------------------------------------------------------------若要明确指出不编译某存储引擎, 可以使用类似如下的选项:-DWITHOUT_&lt;ENGINE&gt;_STORAGE_ENGINE=1例如:-DWITHOUT_EXAMPLE_STORAGE_ENGINE=1-DWITHOUT_FEDERATED_STORAGE_ENGINE=1------------------------------------------------------------若要编译进其他功能, 如SSl等, 可使用类似如下选项来实现编译时使用某库文件或者, 或者不使用某库文件.-DWITH_READLINE=1-DWITH_SSL=system-DWITH_ZLIB=system-DWITH_LIBWRAP=0------------------------------------------------------------其他常用选项:-DMYSQL_TCP_PORT=3306-MYDQL_UNIX_ADDR=/tmp/mysql.sock-DENABLED_LOCAL_INFILE=1-DEXTRA_CHARSETS=all-DDEFAULT_CHARSET=utf8-DDEFAULT_COLLATION=utf8_general_ci-DWITH_DEBUG=0-DENABLE_PROFILING=1------------------------------------------------------------ 开始编译 12345678910111213[root@imarkofu mysql-5.5.40]# cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql-5.5.40 \-DMYSQL_DATADIR=/var/data/mysql \ #数据库目录-DSYSCONFDIR=/etc \ #配置文件目录-DWITH_INNOBASE_STORAGE_ENGINE=1 \ #启用InnoDB存储引擎-DWITH_ARCHIVE_STORAGE_ENGINE=1 \ #启用ARCHIVE存储引擎-DWITH_BLACKHOLE_STORAGE_ENGINE=1 \ #启用黑洞存储引擎-DWITH_READLINE=1 \-DWITH_SSL=system \ #启用SSL协议-DWITH_ZLIB=system \ #启用Zlib压缩-DWITH_LIBWRAP=0 \-DDEFAULT_CHARSET=utf8 \ #设置字符集utf8-DMYSQL_UNIX_ADDR=/tmp/mysql.sock \-DDEFAULT_COLLATION=utf8_general_ci 如果出现以下信息，那么恭喜你第一阶段的配置顺利完成了过程中如果出现错误也不要害怕， 因为你长经验的时刻就要来了， 通常是因为缺少了什么依赖的包而出现的问题， 你可以把你的错误信息铁道Google或者百度中去搜索。12345678910111213....(此处省略一万字)-- Performing Test HAVE_IB_GCC_ATOMIC_BUILTINS-- Performing Test HAVE_IB_GCC_ATOMIC_BUILTINS - Success-- Performing Test HAVE_IB_ATOMIC_PTHREAD_T_GCC-- Performing Test HAVE_IB_ATOMIC_PTHREAD_T_GCC - Success-- Check size of pthread_t-- Check size of pthread_t - done-- Performing Test HAVE_PEERCRED-- Performing Test HAVE_PEERCRED - Success-- Library mysqlclient depends on OSLIBS -lpthread;z;m;rt;/usr/lib64/libssl.so;/usr/lib64/libcrypto.so;dl-- Configuring done-- Generating done-- Build files have been written to: /usr/local/mysql-5.5.40 继续12345678910[root@imarkofu mysql-5.5.40]# make....(此处省略一万字)Scanning dependencies of target udf_example[100%] Building C object sql/CMakeFiles/udf_example.dir/udf_example.c.oLinking C shared module udf_example.so[100%] Built target udf_exampleScanning dependencies of target my_safe_process[100%] Building CXX object mysql-test/lib/My/SafeProcess/CMakeFiles/my_safe_process.dir/safe_process.cc.oLinking CXX executable my_safe_process[100%] Built target my_safe_process 如果没有报错，继续12345678910[root@imarkofu mysql-5.5.40]# make install....(此处省略一万字)-- Installing: /usr/local/mysql-5.5.40/man/man1/mysql_upgrade.1-- Installing: /usr/local/mysql-5.5.40/man/man1/mysqlslap.1-- Installing: /usr/local/mysql-5.5.40/man/man1/replace.1-- Installing: /usr/local/mysql-5.5.40/man/man1/mysql.1-- Installing: /usr/local/mysql-5.5.40/man/man1/mysql_setpermission.1-- Installing: /usr/local/mysql-5.5.40/man/man1/mysql_secure_installation.1-- Installing: /usr/local/mysql-5.5.40/man/man1/mysqlimport.1-- Installing: /usr/local/mysql-5.5.40/man/man8/mysqld.8 全部安装ok之后我们来配置下文档的权限123456789101112131415161718192021222324[root@imarkofu mysql-5.5.40]# chown :mysql /usr/local/mysql-5.5.40 -R[root@imarkofu mysql-5.5.40]# cd /usr/local/mysql-5.5.40/[root@imarkofu mysql-5.5.40]# chmod +x scripts/mysql_install_db[root@imarkofu mysql-5.5.40]# scripts/mysql_install_db --user=mysql --datadir=/var/data/mysql/ #执行初始化脚本....(此处省略一万字)./bin/mysqladmin -u root password &apos;new-password&apos;./bin/mysqladmin -u root -h imarkofu password &apos;new-password&apos; Alternatively you can run:./bin/mysql_secure_installation which will also give you the option of removing the testdatabases and anonymous user created by default. This isstrongly recommended for production servers. See the manual for more instructions. You can start the MySQL daemon with:cd . ; ./bin/mysqld_safe &amp; You can test the MySQL daemon with mysql-test-run.plcd ./mysql-test ; perl mysql-test-run.pl Please report any problems at http://bugs.mysql.com/ 如果你获得的信息和上面一样的话, 恭喜你, 你又离成功近了一步12[root@imarkofu mysql-5.5.40]# ls /var/data/mysql/ #看一下是否生成了文件mysql performance_schema test 如果是这样那么继续创建服务脚本123[root@imarkofu mysql-5.5.40]# cp support-files/mysql.server /etc/rc.d/init.d/mysqld [root@imarkofu mysql-5.5.40]# chmod +x /etc/rc.d/init.d/mysqld #添加mysqld执行权限[root@imarkofu mysql-5.5.40]# chkconfig --add mysqld #添加开机启动 创建配置文件1234567891011121314151617181920212223242526[root@imarkofu mysql-5.5.40]# mv /etc/my.cnf&#123;,.bak&#125;[root@imarkofu mysql-5.5.40]# cp support-files/my-large.cnf /etc/my.cnf[root@imarkofu mysql-5.5.40]# vim /etc/my.cnf#找到如下部分[mysqld]port = 3306socket = /tmp/mysql.sockskip-external-lockingkey_buffer_size = 256Mmax_allowed_packet = 1Mtable_open_cache = 256sort_buffer_size = 1Mread_buffer_size = 1Mread_rnd_buffer_size = 4Mmyisam_sort_buffer_size = 64Mthread_cache_size = 8query_cache_size= 16M# Try number of CPU&apos;s*2 for thread_concurrencythread_concurrency = 8datadir= /var/data/mysql #添加次行内容, 就是数据库文件存放路径:wq#保存退出[root@imarkofu mysql-5.5.40]# vim /etc/profile.d/mysql.shexport PATH=/usr/local/mysql-5.5.40/bin:$PATH #添加此行 好了，尝试着启动MySQL服务123456[root@imarkofu mysql-5.5.40]# service mysqld startStarting MySQL.. [ OK ][root@imarkofu mysql-5.5.40]#[root@imarkofu mysql-5.5.40]# ss -tnl| grep :3306 LISTEN 0 50 *:3306 *:* #发现正常监听 3306端口 距离胜利越来越近了然后配置MySQL管理员密码进行初始化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950[root@imarkofu mysql-5.5.40]# mysql #使用客户端登录Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 1Server version: 5.5.40-log Source distributionCopyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; #查看一下默认存在的用户mysql&gt; select user,password,host from mysql.user; +------+----------+-----------+| user | password | host |+------+----------+-----------+| root | | localhost || root | | imarkofu || root | | 127.0.0.1 || root | | ::1 || | | localhost || | | imarkofu |+------+----------+-----------+6 rows in set (0.00 sec)mysql&gt; #删除默认存在的账户, 要求用户只能从本地服务器访问数据库mysql&gt; delete from mysql.user where host!=&apos;localhost&apos;; Query OK, 4 rows affected (0.00 sec)#修改root管理员账号密码mysql&gt; update mysql.user set password=PASSWORD(&apos;p@ssw0rd&apos;) where user=&apos;root&apos;; Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0 #更新数据库mysql&gt; FLUSH PRIVILEGES;Query OK, 0 rows affected (0.00 sec) #看一下修改后的结果mysql&gt; select user,password,host from mysql.user;+------+-------------------------------------------+-----------+| user | password | host |+------+-------------------------------------------+-----------+| root | *D7E39C3AF517EC9EF7086223B036E0B4F22821F8 | localhost || | | localhost |+------+-------------------------------------------+-----------+2 rows in set (0.00 sec)mysql&gt; \qBye[root@imarkofu mysql-5.5.40]# 然后就可以使用新密码登陆了1234567891011[root@imarkofu mysql-5.5.40]# mysql -u root -h localhost -pEnter password: #输入刚才设置的密码Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 4Server version: 5.5.40-log Source distributionCopyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; 好了MySQL到此 就安装成功了对了，忘记了导入开发的库文件了， ok 很快就好123456789[root@imarkofu mysql-5.5.40]# ln -sv /usr/local/mysql/include/ /usr/include/mysql #软连接到系统库中[root@imarkofu mysql-5.5.40]# vim /etc/ld.so.conf.d/mysql.conf #编辑这个文件, 并且添加如下路径/usr/local/mysql-5.5.40/lib[root@imarkofu mysql-5.5.40]# ldconfig #重新加载库文件[root@imarkofu mysql-5.5.40]# ldconfig -p | grep mysql #让我们来检查下是不是加载好了 libmysqlclient_r.so.16 (libc6,x86-64) =&gt; /usr/lib64/mysql/libmysqlclient_r.so.16 libmysqlclient.so.18 (libc6,x86-64) =&gt; /usr/local/mysql-5.5.40/lib/libmysqlclient.so.18 libmysqlclient.so.16 (libc6,x86-64) =&gt; /usr/lib64/mysql/libmysqlclient.so.16 libmysqlclient.so (libc6,x86-64) =&gt; /usr/local/mysql-5.5.40/lib/libmysqlclient.so 至此，MySQL5.5.40 编译安装完成]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mysql in 子查询 效率慢 优化]]></title>
      <url>%2F2016%2F11%2F30%2Foptimize-mysql-in-subqueries%2F</url>
      <content type="text"><![CDATA[现在的CMS系统、博客系统、BBS等都喜欢使用标签tag作交叉链接，因此我也尝鲜用了下。但用了后发现我想查询某个tag的文章列表时速度很慢，达到5秒之久！百思不解(后来终于解决)，我的表结构是下面这样的，文章只有690篇。文章表article(id,title,content)标签表tag(tid,tag_name)标签文章中间表article_tag(id,tag_id,article_id)其中有个标签的tid是135，我帮查询标签tid是135的文章列表用以下语句时发现速度好慢,我文章才690篇 select id,title from article where id in(select article_id from article_tag where tag_id=135) 其中这条速度很快： select article_id from article_tag where tag_id=135 查询结果是五篇文章，id为428,429,430,431,432我用写死的方式用下面sql来查文章也很快 select id,title from article where id in(428,429,430,431,432) 我在SqlServer中好像不会这样慢，不知MySQL怎样写好点，也想不出慢在哪里。后来我找到了解决方法： select id,title from article where id in(select article_id from (select article_id from article_tag where tag_id=135) as tbt) 其它解决方法：（举例） select * from abc_number_prop where number_id in (select number_id from abc_number_phone where phone = ‘82306839’); 为了节省篇幅，省略了输出内容，下同。 67 rows in set (12.00 sec) 只有67行数据返回，却花了12秒，而系统中可能同时会有很多这样的查询，系统肯定扛不住。用desc看一下(注：explain也可) mysql&gt;desc select * from abc_number_prop where number_id in (select number_id from abc_number_phone where phone = ‘82306839’);+—-+——————–+——————+——–+—————–+——-+———+————+———+————————–+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+——————–+——————+——–+—————–+——-+———+————+———+————————–+| 1 | PRIMARY | abc_number_prop | ALL | NULL | NULL | NULL | NULL | 2679838 | Using where || 2 | DEPENDENT SUBQUERY | abc_number_phone | eq_ref | phone,number_id | phone | 70 | const,func | 1 | Using where; Using index |+—-+——————–+——————+——–+—————–+——-+———+————+———+————————–+2 rows in set (0.00 sec) 从上面的信息可以看出，在执行此查询时会扫描两百多万行，难道是没有创建索引吗，看一下 mysql&gt;show index from abc_number_phone;+——————+————+————-+————–+—————–+———–+————-+———-+——–+——+————+———+—————+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+——————+————+————-+————–+—————–+———–+————-+———-+——–+——+————+———+—————+| abc_number_phone | 0 | PRIMARY | 1 | number_phone_id | A | 36879 | NULL | NULL | | BTREE | | || abc_number_phone | 0 | phone | 1 | phone | A | 36879 | NULL | NULL | | BTREE | | || abc_number_phone | 0 | phone | 2 | number_id | A | 36879 | NULL | NULL | | BTREE | | || abc_number_phone | 1 | number_id | 1 | number_id | A | 36879 | NULL | NULL | | BTREE | | || abc_number_phone | 1 | created_by | 1 | created_by | A | 36879 | NULL | NULL | | BTREE | | || abc_number_phone | 1 | modified_by | 1 | modified_by | A | 36879 | NULL | NULL | YES | BTREE | | |+——————+————+————-+————–+—————–+———–+————-+———-+——–+——+————+———+—————+6 rows in set (0.06 sec) mysql&gt;show index from abc_number_prop;+—————–+————+————-+————–+—————-+———–+————-+———-+——–+——+————+———+—————+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+—————–+————+————-+————–+—————-+———–+————-+———-+——–+——+————+———+—————+| abc_number_prop | 0 | PRIMARY | 1 | number_prop_id | A | 311268 | NULL | NULL | | BTREE | | || abc_number_prop | 1 | number_id | 1 | number_id | A | 311268 | NULL | NULL | | BTREE | | || abc_number_prop | 1 | created_by | 1 | created_by | A | 311268 | NULL | NULL | | BTREE | | || abc_number_prop | 1 | modified_by | 1 | modified_by | A | 311268 | NULL | NULL | YES | BTREE | | |+—————–+————+————-+————–+—————-+———–+————-+———-+——–+——+————+———+—————+4 rows in set (0.15 sec) 从上面的输出可以看出，这两张表在number_id字段上创建了索引的。看看子查询本身有没有问题。 mysql&gt;desc select number_id from abc_number_phone where phone = ‘82306839’;+—-+————-+——————+——+—————+——-+———+——-+——+————————–+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+—-+————-+——————+——+—————+——-+———+——-+——+————————–+| 1 | SIMPLE | abc_number_phone | ref | phone | phone | 66 | const | 6 | Using where; Using index |+—-+————-+——————+——+—————+——-+———+——-+——+————————–+1 row in set (0.00 sec) 没有问题，只需要扫描几行数据，索引起作用了。查询出来看看mysql&gt;select number_id from abc_number_phone where phone = ‘82306839’; +———–+| number_id |+———–+| 8585 || 10720 || 148644 || 151307 || 170691 || 221897 |+———–+6 rows in set (0.00 sec) 直接把子查询得到的数据放到上面的查询中 mysql&gt; select * from abc_number_prop where number_id in (8585, 10720, 148644, 151307, 170691, 221897);67 rows in set (0.03 sec) 速度也快，看来MySQL在处理子查询的时候是不够好。我在MySQL 5.1.42 和 MySQL 5.5.19 都进行了尝试，都有这个问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS获取当前对象大小属性以及屏幕分辨率属性等]]></title>
      <url>%2F2016%2F11%2F30%2Fgets-the-screen-properties-by-JS%2F</url>
      <content type="text"><![CDATA[JS获取当前对象大小属性以及屏幕分辨率属性等123456789101112131415161718192021222324&lt;script type="text/javascript"&gt;function getInfo()&#123; var s = ""; s += " 网页可见区域宽："+ document.body.clientWidth+"\n"; s += " 网页可见区域高："+ document.body.clientHeight+"\n"; s += " 网页可见区域宽："+ document.body.offsetWidth + " (包括边线和滚动条的宽)"+"\n"; s += " 网页可见区域高："+ document.body.offsetHeight + " (包括边线的宽)"+"\n"; s += " 网页正文全文宽："+ document.body.scrollWidth+"\n"; s += " 网页正文全文高："+ document.body.scrollHeight+"\n"; s += " 网页被卷去的高(ff)："+ document.body.scrollTop+"\n"; s += " 网页被卷去的高(ie)："+ document.documentElement.scrollTop+"\n"; s += " 网页被卷去的左："+ document.body.scrollLeft+"\n"; s += " 网页正文部分上："+ window.screenTop+"\n"; s += " 网页正文部分左："+ window.screenLeft+"\n"; s += " 屏幕分辨率的高："+ window.screen.height+"\n"; s += " 屏幕分辨率的宽："+ window.screen.width+"\n"; s += " 屏幕可用工作区高度："+ window.screen.availHeight+"\n"; s += " 屏幕可用工作区宽度："+ window.screen.availWidth+"\n"; s += " 你的屏幕设置是 "+ window.screen.colorDepth +" 位彩色"+"\n"; s += " 你的屏幕设置 "+ window.screen.deviceXDPI +" 像素/英寸"+"\n"; alert (s);&#125;getInfo();&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Redis的redis.conf中文版（基于2.4）]]></title>
      <url>%2F2016%2F11%2F29%2Ftranslation-redid-conf%2F</url>
      <content type="text"><![CDATA[redis 2.4的conf文件的中文翻译，大致参考。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376# Redis示例配置文件# 注意单位问题：当需要设置内存大小的时候，可以使用类似1k、5GB、4M这样的常见格式：## 1k =&gt; 1000 bytes# 1kb =&gt; 1024 bytes# 1m =&gt; 1000000 bytes# 1mb =&gt; 1024*1024 bytes# 1g =&gt; 1000000000 bytes# 1gb =&gt; 1024*1024*1024 bytes## 单位是大小写不敏感的，所以1GB 1Gb 1gB的写法都是完全一样的。# Redis默认是不作为守护进程来运行的。你可以把这个设置为&quot;yes&quot;让它作为守护进程来运行。# 注意，当作为守护进程的时候，Redis会把进程ID写到 /var/run/redis.piddaemonize no# 当以守护进程方式运行的时候，Redis会把进程ID默认写到 /var/run/redis.pid。你可以在这里修改路径。pidfile /var/run/redis.pid# 接受连接的特定端口，默认是6379。# 如果端口设置为0，Redis就不会监听TCP套接字。port 6379# 如果你想的话，你可以绑定单一接口；如果这里没单独设置，那么所有接口的连接都会被监听。## bind 127.0.0.1# 指定用来监听连接的unxi套接字的路径。这个没有默认值，所以如果你不指定的话，Redis就不会通过unix套接字来监听。## unixsocket /tmp/redis.sock# unixsocketperm 755#一个客户端空闲多少秒后关闭连接。(0代表禁用，永不关闭)timeout 0# 设置服务器调试等级。# 可能值：# debug （很多信息，对开发/测试有用）# verbose （很多精简的有用信息，但是不像debug等级那么多）# notice （适量的信息，基本上是你生产环境中需要的程度）# warning （只有很重要/严重的信息会记录下来）loglevel verbose# 指明日志文件名。也可以使用&quot;stdout&quot;来强制让Redis把日志信息写到标准输出上。# 注意：如果Redis以守护进程方式运行，而你设置日志显示到标准输出的话，那么日志会发送到 /dev/nulllogfile stdout# 要使用系统日志记录器很简单，只要设置 &quot;syslog-enabled&quot; 为 &quot;yes&quot; 就可以了。# 然后根据需要设置其他一些syslog参数就可以了。# syslog-enabled no# 指明syslog身份# syslog-ident redis# 指明syslog的设备。必须是一个用户或者是 LOCAL0 ~ LOCAL7 之一。# syslog-facility local0# 设置数据库个数。默认数据库是 DB 0，你可以通过SELECT &lt;dbid&gt; WHERE dbid（0～&apos;databases&apos; - 1）来为每个连接使用不同的数据库。databases 16################################ 快照 ################################### 把数据库存到磁盘上:## save &lt;seconds&gt; &lt;changes&gt;# # 会在指定秒数和数据变化次数之后把数据库写到磁盘上。## 下面的例子将会进行把数据写入磁盘的操作:# 900秒（15分钟）之后，且至少1次变更# 300秒（5分钟）之后，且至少10次变更# 60秒之后，且至少10000次变更## 注意：你要想不写磁盘的话就把所有 &quot;save&quot; 设置注释掉就行了。save 900 1save 300 10save 60 10000# 当导出到 .rdb 数据库时是否用LZF压缩字符串对象。# 默认设置为 &quot;yes&quot;，所以几乎总是生效的。# 如果你想节省CPU的话你可以把这个设置为 &quot;no&quot;，但是如果你有可压缩的key的话，那数据文件就会更大了。rdbcompression yes# 数据库的文件名dbfilename dump.rdb# 工作目录## 数据库会写到这个目录下，文件名就是上面的 &quot;dbfilename&quot; 的值。# # 累加文件也放这里。# # 注意你这里指定的必须是目录，不是文件名。dir ./################################# 同步 ################################### 主从同步。通过 slaveof 配置来实现Redis实例的备份。# 注意，这里是本地从远端复制数据。也就是说，本地可以有不同的数据库文件、绑定不同的IP、监听不同的端口。## slaveof &lt;masterip&gt; &lt;masterport&gt;# 如果master设置了密码（通过下面的 &quot;requirepass&quot; 选项来配置），那么slave在开始同步之前必须进行身份验证，否则它的同步请求会被拒绝。## masterauth &lt;master-password&gt;# 当一个slave失去和master的连接，或者同步正在进行中，slave的行为有两种可能：## 1) 如果 slave-serve-stale-data 设置为 &quot;yes&quot; (默认值)，slave会继续响应客户端请求，可能是正常数据，也可能是还没获得值的空数据。# 2) 如果 slave-serve-stale-data 设置为 &quot;no&quot;，slave会回复&quot;正在从master同步（SYNC with master in progress）&quot;来处理各种请求，除了 INFO 和 SLAVEOF 命令。#slave-serve-stale-data yes# slave根据指定的时间间隔向服务器发送ping请求。# 时间间隔可以通过 repl_ping_slave_period 来设置。# 默认10秒。## repl-ping-slave-period 10# 下面的选项设置了大块数据I/O、向master请求数据和ping响应的过期时间。# 默认值60秒。## 一个很重要的事情是：确保这个值比 repl-ping-slave-period 大，否则master和slave之间的传输过期时间比预想的要短。## repl-timeout 60################################## 安全 #################################### 要求客户端在处理任何命令时都要验证身份和密码。# 这在你信不过来访者时很有用。## 为了向后兼容的话，这段应该注释掉。而且大多数人不需要身份验证（例如：它们运行在自己的服务器上。）# # 警告：因为Redis太快了，所以居心不良的人可以每秒尝试150k的密码来试图破解密码。# 这意味着你需要一个高强度的密码，否则破解太容易了。## requirepass foobared# 命令重命名## 在共享环境下，可以为危险命令改变名字。比如，你可以为 CONFIG 改个其他不太容易猜到的名字，这样你自己仍然可以使用，而别人却没法做坏事了。## 例如:## rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52## 甚至也可以通过给命令赋值一个空字符串来完全禁用这条命令：## rename-command CONFIG &quot;&quot;################################### 限制 ###################################### 设置最多同时连接客户端数量。# 默认没有限制，这个关系到Redis进程能够打开的文件描述符数量。# 特殊值&quot;0&quot;表示没有限制。# 一旦达到这个限制，Redis会关闭所有新连接并发送错误&quot;达到最大用户数上限（max number of clients reached）&quot;## maxclients 128# 不要用比设置的上限更多的内存。一旦内存使用达到上限，Redis会根据选定的回收策略（参见：maxmemmory-policy）删除key。## 如果因为删除策略问题Redis无法删除key，或者策略设置为 &quot;noeviction&quot;，Redis会回复需要更多内存的错误信息给命令。# 例如，SET,LPUSH等等。但是会继续合理响应只读命令，比如：GET。## 在使用Redis作为LRU缓存，或者为实例设置了硬性内存限制的时候（使用 &quot;noeviction&quot; 策略）的时候，这个选项还是满有用的。## 警告：当一堆slave连上达到内存上限的实例的时候，响应slave需要的输出缓存所需内存不计算在使用内存当中。# 这样当请求一个删除掉的key的时候就不会触发网络问题／重新同步的事件，然后slave就会收到一堆删除指令，直到数据库空了为止。## 简而言之，如果你有slave连上一个master的话，那建议你把master内存限制设小点儿，确保有足够的系统内存用作输出缓存。# （如果策略设置为&quot;noeviction&quot;的话就不无所谓了）## maxmemory &lt;bytes&gt;# 内存策略：如果达到内存限制了，Redis如何删除key。你可以在下面五个策略里面选：# # volatile-lru -&gt; 根据LRU算法生成的过期时间来删除。# allkeys-lru -&gt; 根据LRU算法删除任何key。# volatile-random -&gt; 根据过期设置来随机删除key。# allkeys-&gt;random -&gt; 无差别随机删。# volatile-ttl -&gt; 根据最近过期时间来删除（辅以TTL）# noeviction -&gt; 谁也不删，直接在写操作时返回错误。# # 注意：对所有策略来说，如果Redis找不到合适的可以删除的key都会在写操作时返回一个错误。## 这里涉及的命令：set setnx setex append# incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd# sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby# zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby# getset mset msetnx exec sort## 默认值如下：## maxmemory-policy volatile-lru# LRU和最小TTL算法的实现都不是很精确，但是很接近（为了省内存），所以你可以用样例做测试。# 例如：默认Redis会检查三个key然后取最旧的那个，你可以通过下面的配置项来设置样本的个数。## maxmemory-samples 3############################## 纯累加模式 ################################ 默认情况下，Redis是异步的把数据导出到磁盘上。这种情况下，当Redis挂掉的时候，最新的数据就丢了。# 如果不希望丢掉任何一条数据的话就该用纯累加模式：一旦开启这个模式，Redis会把每次写入的数据在接收后都写入 appendonly.aof 文件。# 每次启动时Redis都会把这个文件的数据读入内存里。## 注意，异步导出的数据库文件和纯累加文件可以并存（你得把上面所有&quot;save&quot;设置都注释掉，关掉导出机制）。# 如果纯累加模式开启了，那么Redis会在启动时载入日志文件而忽略导出的 dump.rdb 文件。## 重要：查看 BGREWRITEAOF 来了解当累加日志文件太大了之后，怎么在后台重新处理这个日志文件。appendonly no# 纯累加文件名字（默认：&quot;appendonly.aof&quot;）# appendfilename appendonly.aof# fsync() 请求操作系统马上把数据写到磁盘上，不要再等了。# 有些操作系统会真的把数据马上刷到磁盘上；有些则要磨蹭一下，但是会尽快去做。## Redis支持三种不同的模式：## no：不要立刻刷，只有在操作系统需要刷的时候再刷。比较快。# always：每次写操作都立刻写入到aof文件。慢，但是最安全。# everysec：每秒写一次。折衷方案。## 默认的 &quot;everysec&quot; 通常来说能在速度和数据安全性之间取得比较好的平衡。# 如果你真的理解了这个意味着什么，那么设置&quot;no&quot;可以获得更好的性能表现（如果丢数据的话，则只能拿到一个不是很新的快照）；# 或者相反的，你选择 &quot;always&quot; 来牺牲速度确保数据安全、完整。## 如果拿不准，就用 &quot;everysec&quot;# appendfsync alwaysappendfsync everysec# appendfsync no# 如果AOF的同步策略设置成 &quot;always&quot; 或者 &quot;everysec&quot;，那么后台的存储进程（后台存储或写入AOF日志）会产生很多磁盘I/O开销。# 某些Linux的配置下会使Redis因为 fsync() 而阻塞很久。# 注意，目前对这个情况还没有完美修正，甚至不同线程的 fsync() 会阻塞我们的 write(2) 请求。## 为了缓解这个问题，可以用下面这个选项。它可以在 BGSAVE 或 BGREWRITEAOF 处理时阻止 fsync()。# # 这就意味着如果有子进程在进行保存操作，那么Redis就处于&quot;不可同步&quot;的状态。# 这实际上是说，在最差的情况下可能会丢掉30秒钟的日志数据。（默认Linux设定）# # 如果你有延迟的问题那就把这个设为 &quot;yes&quot;，否则就保持 &quot;no&quot;，这是保存持久数据的最安全的方式。no-appendfsync-on-rewrite no# 自动重写AOF文件## 如果AOF日志文件大到指定百分比，Redis能够通过 BGREWRITEAOF 自动重写AOF日志文件。# # 工作原理：Redis记住上次重写时AOF日志的大小（或者重启后没有写操作的话，那就直接用此时的AOF文件），# 基准尺寸和当前尺寸做比较。如果当前尺寸超过指定比例，就会触发重写操作。## 你还需要指定被重写日志的最小尺寸，这样避免了达到约定百分比但尺寸仍然很小的情况还要重写。## 指定百分比为0会禁用AOF自动重写特性。auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb################################## 慢查询日志 #################################### Redis慢查询日志可以记录超过指定时间的查询。运行时间不包括各种I/O时间。# 例如：连接客户端，发送响应数据等。只计算命令运行的实际时间（这是唯一一种命令运行线程阻塞而无法同时为其他请求服务的场景）# # 你可以为慢查询日志配置两个参数：一个是超标时间，单位为微妙，记录超过个时间的命令。# 另一个是慢查询日志长度。当一个新的命令被写进日志的时候，最老的那个记录会被删掉。## 下面的时间单位是微秒，所以1000000就是1秒。注意，负数时间会禁用慢查询日志，而0则会强制记录所有命令。slowlog-log-slower-than 10000# 这个长度没有限制。只要有足够的内存就行。你可以通过 SLOWLOG RESET 来释放内存。（译者注：日志居然是在内存里的Orz）slowlog-max-len 128################################ 虚拟内存 ################################## 警告！虚拟内存在Redis 2.4是反对的。### 非常不鼓励使用虚拟内存！！# 虚拟内存可以使Redis在内存不够的情况下仍然可以将所有数据序列保存在内存里。# 为了做到这一点，高频key会调到内存里，而低频key会转到交换文件里，就像操作系统使用内存页一样。## 要使用虚拟内存，只要把 &quot;vm-enabled&quot; 设置为 &quot;yes&quot;，并根据需要设置下面三个虚拟内存参数就可以了。vm-enabled no# vm-enabled yes# 这是交换文件的路径。估计你猜到了，交换文件不能在多个Redis实例之间共享，所以确保每个Redis实例使用一个独立交换文件。## 最好的保存交换文件（被随机访问）的介质是固态硬盘（SSD）。## *** 警告 *** 如果你使用共享主机，那么默认的交换文件放到 /tmp 下是不安全的。# 创建一个Redis用户可写的目录，并配置Redis在这里创建交换文件。vm-swap-file /tmp/redis.swap# &quot;vm-max-memory&quot; 配置虚拟内存可用的最大内存容量。# 如果交换文件还有空间的话，所有超标部分都会放到交换文件里。## &quot;vm-max-memory&quot; 设置为0表示系统会用掉所有可用内存。# 这默认值不咋地，只是把你能用的内存全用掉了，留点余量会更好。# 例如，设置为剩余内存的60%-80%。vm-max-memory 0# Redis交换文件是分成多个数据页的。# 一个可存储对象可以被保存在多个连续页里，但是一个数据页无法被多个对象共享。# 所以，如果你的数据页太大，那么小对象就会浪费掉很多空间。# 如果数据页太小，那用于存储的交换空间就会更少（假定你设置相同的数据页数量）## 如果你使用很多小对象，建议分页尺寸为64或32个字节。# 如果你使用很多大对象，那就用大一些的尺寸。# 如果不确定，那就用默认值 :)vm-page-size 32# 交换文件里数据页总数。# 根据内存中分页表（已用/未用的数据页分布情况），磁盘上每8个数据页会消耗内存里1个字节。## 交换区容量 = vm-page-size * vm-pages## 根据默认的32字节的数据页尺寸和134217728的数据页数来算，Redis的数据页文件会占4GB，而内存里的分页表会消耗16MB内存。## 为你的应验程序设置最小且够用的数字比较好，下面这个默认值在大多数情况下都是偏大的。vm-pages 134217728# 同时可运行的虚拟内存I/O线程数。# 这些线程可以完成从交换文件进行数据读写的操作，也可以处理数据在内存与磁盘间的交互和编码/解码处理。# 多一些线程可以一定程度上提高处理效率，虽然I/O操作本身依赖于物理设备的限制，不会因为更多的线程而提高单次读写操作的效率。## 特殊值0会关闭线程级I/O，并会开启阻塞虚拟内存机制。vm-max-threads 4############################### 高级配置 ################################ 当有大量数据时，适合用哈希编码（需要更多的内存），元素数量上限不能超过给定限制。# 你可以通过下面的选项来设定这些限制：hash-max-zipmap-entries 512hash-max-zipmap-value 64# 与哈希相类似，数据元素较少的情况下，可以用另一种方式来编码从而节省大量空间。# 这种方式只有在符合下面限制的时候才可以用：list-max-ziplist-entries 512list-max-ziplist-value 64# 还有这样一种特殊编码的情况：数据全是64位无符号整型数字构成的字符串。# 下面这个配置项就是用来限制这种情况下使用这种编码的最大上限的。set-max-intset-entries 512# 与第一、第二种情况相似，有序序列也可以用一种特别的编码方式来处理，可节省大量空间。# 这种编码只适合长度和元素都符合下面限制的有序序列：zset-max-ziplist-entries 128zset-max-ziplist-value 64# 哈希刷新，每100个CPU毫秒会拿出1个毫秒来刷新Redis的主哈希表（顶级键值映射表）。# redis所用的哈希表实现（见dict.c）采用延迟哈希刷新机制：你对一个哈希表操作越多，哈希刷新操作就越频繁；# 反之，如果服务器非常不活跃那么也就是用点内存保存哈希表而已。# # 默认是每秒钟进行10次哈希表刷新，用来刷新字典，然后尽快释放内存。## 建议：# 如果你对延迟比较在意的话就用 &quot;activerehashing no&quot;，每个请求延迟2毫秒不太好嘛。# 如果你不太在意延迟而希望尽快释放内存的话就设置 &quot;activerehashing yes&quot;。activerehashing yes################################## 包含 #################################### 包含一个或多个其他配置文件。# 这在你有标准配置模板但是每个redis服务器又需要个性设置的时候很有用。# 包含文件特性允许你引人其他配置文件，所以好好利用吧。## include /path/to/local.conf# include /path/to/other.conf]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HashSet、LinkedHashSet、TreeSet使用区别]]></title>
      <url>%2F2016%2F11%2F29%2Fthe-difference-of-HashSet-LinkedHashSet-TreeSet%2F</url>
      <content type="text"><![CDATA[HashSet：哈希表是通过使用称为散列法的机制来存储信息的，元素并没有以某种特定顺序来存放；LinkedHashSet：以元素插入的顺序来维护集合的链接表，允许以插入的顺序在集合中迭代；TreeSet：提供一个使用树结构存储Set接口的实现，对象以升序顺序存储，访问和遍历的时间很快。用例代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.HashSet; import java.util.LinkedHashSet; import java.util.TreeSet; /** * @description 几个set的比较 * HashSet：哈希表是通过使用称为散列法的机制来存储信息的，元素并没有以某种特定顺序来存放； * LinkedHashSet：以元素插入的顺序来维护集合的链接表，允许以插入的顺序在集合中迭代； * TreeSet：提供一个使用树结构存储Set接口的实现，对象以升序顺序存储，访问和遍历的时间很快。 * @author gbwl_cgl * */ public class SetDemo &#123; public static void main(String[] args) &#123; HashSet&lt;String&gt; hs = new HashSet&lt;String&gt;(); hs.add("B"); hs.add("A"); hs.add("D"); hs.add("E"); hs.add("C"); hs.add("F"); System.out.println("HashSet 顺序:\n"+hs); LinkedHashSet&lt;String&gt; lhs = new LinkedHashSet&lt;String&gt;(); lhs.add("B"); lhs.add("A"); lhs.add("D"); lhs.add("E"); lhs.add("C"); lhs.add("F"); System.out.println("LinkedHashSet 顺序:\n"+lhs); TreeSet&lt;String&gt; ts = new TreeSet&lt;String&gt;(); ts.add("B"); ts.add("A"); ts.add("D"); ts.add("E"); ts.add("C"); ts.add("F"); System.out.println("TreeSet 顺序:\n"+ts); &#125; &#125; 输出效果： HashSet 顺序: [D, E, F, A, B, C]LinkedHashSet 顺序: [B, A, D, E, C, F]TreeSet 顺序: [A, B, C, D, E, F]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java集合间的相互转换]]></title>
      <url>%2F2016%2F11%2F29%2Fjava-collection-transformation%2F</url>
      <content type="text"><![CDATA[代码演示List&lt;–&gt;数组、List&lt;–&gt;Set、数组&lt;–&gt;Set、Map将键转化为Set、Map将值转化为Set、Map将值转化为List等集合常用转化操作。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.ArrayList;import java.util.Arrays;import java.util.HashMap;import java.util.HashSet;import java.util.List;import java.util.Map;import java.util.Set;/** * @Title: CollectionConversion.java&lt;br&gt; * @package: com.imarkofu.demo&lt;br&gt; * @Description:集合转换&lt;br&gt; * @author gbwl&lt;br&gt; * @date 2015年5月11日 下午3:57:01&lt;br&gt; */public class CollectionConversion &#123; public static void main(String[] args) &#123; // List--&gt;数组 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("蹇伟"); list.add("Jerval"); list.add("杰威"); Object[] objects = list.toArray();// 返回Object数组 System.out.println("objects:" + Arrays.toString(objects)); String[] strings1 = new String[list.size()]; list.toArray(strings1);// 将转化后的数组放入已经创建好的对象中 System.out.println("strings1:" + Arrays.toString(strings1)); String[] strings2 = list.toArray(new String[0]);// 将转化后的数组赋给新对象 System.out.println("strings2:" + Arrays.toString(strings2)); // 数组--&gt;List String[] ss = &#123; "JJ", "KK" &#125;; List&lt;String&gt; list1 = Arrays.asList(ss); List&lt;String&gt; list2 = Arrays.asList("AAA", "BBB"); System.out.println(list1); System.out.println(list2); // List--&gt;Set List&lt;String&gt; list3 = new ArrayList&lt;String&gt;(new HashSet&lt;String&gt;()); // Set--&gt;List Set&lt;String&gt; set = new HashSet&lt;String&gt;(new ArrayList&lt;String&gt;()); // 数组--&gt;Set String[] strs = &#123; "AA", "BB" &#125;; Set&lt;String&gt; set2 = new HashSet&lt;String&gt;(Arrays.asList(strs)); System.out.println(set2); // Set--&gt;数组 Set&lt;String&gt; set3 = new HashSet&lt;String&gt;(Arrays.asList("PP", "OO")); String[] strSet = new String[set3.size()]; set3.toArray(strSet); System.out.println(Arrays.toString(strSet)); // Map操作 Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put("YYY", "UUU"); map.put("RRR", "TTT"); // 将键转化为Set Set&lt;String&gt; mapKeySet = map.keySet(); // 将值转化为Set Set&lt;String&gt; mapValuesSet = new HashSet&lt;String&gt;(map.values()); // 将值转化为List List&lt;String&gt; mapValuesList = new ArrayList&lt;String&gt;(map.values()); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[curl命令使用指南]]></title>
      <url>%2F2016%2F11%2F29%2Fcurl-command-usage-guide%2F</url>
      <content type="text"><![CDATA[我一向以为，curl只是一个编程用的函数库。最近才发现，这个命令本身，就是一个无比有用的网站开发工具，请看我整理的它的用法。curl是一种命令行工具，作用是发出网络请求，然后得到和提取数据，显示在”标准输出”（stdout）上面。 curl的选项功能1234567891011121314151617181920212223242526不带任何参数时curl将返回指定url中的数据并打印在屏幕上 -u 使用用户名和密码登陆。如curl -uname:passwd URL -b/--cookie &lt;name=data&gt; 向服务器提交cookie，若无=则name视为文件名，例如：curl -b cookie.txt www.imarkofu.com -o out 将指定curl返回保存为out文件，内容从html/jpg到各种MIME类型文件。如curl -o page.html URL -d &lt;key=value&gt; 向服务器POST表单数据 例如：curl -d &quot;pageSize=8&amp;pageNo=5&quot; http://www.imarkofu.com/load.do -A/--user-agent &lt;ua&gt; 指定发送请求的用户代理，例如：curl -A My-Agent/1.0.0 www.imarkofu.com -x ip:port 指定使用的http代理，例如：curl -x 192.168.1.1:8080 www.imarkofu.com -D head.txt 将服务器的返回的header保存为文件，头部的cookie也可被保存，例如：curl -D header.txt www.imarkofu.com -L 当页面有跳转的时候，输出跳转到的页面 -I header信息 当有跳转时，可以通过 curl -L -I URL|grep Location 来确定跳转到的新url地址 -c &lt;file&gt; 保存服务器的cookie文件 -e url 设置引用头的值 -T localfile 向服务器PUT文件 例如：curl -T xxx.doc www.imarkofu.com/upload.do -F &lt;key=value&gt; 向服务器POST表单，例如：curl -F &quot;web=@index.html;type=text/html&quot; url.com -E cert.pem 指定本地证书 -H &lt;header:value&gt; 为HTTP请求设置任意header及值。如curl -H &quot;Connection:keep-alive&quot; http://www.imarkofu.com -X/--request method 用户定义的HTTP请求方法名如 curl -X GET www.imarkofu.com -compressed 采用压缩方式接收返回数据 -connect-timeout `&lt;`s`&gt;` 设置超时时间 -v 详细输出，包含请求和响应的首部 --retry num --retry timeo 指定重试的次数和间隔 --tcp-nodelay 打开TCP_NODELAY选项 不进行捎带确认 -O 按服务器上的名称保存下载的文件 -r/--range from-to 下载指定range内的数据 -C 在保存文件时进行续传 curl的常见使用curl查看web站点rt123456789101112131415161718curl -o /dev/null -s -w %&#123;time_namelookup&#125;::%&#123;time_connect&#125;::%&#123;time_starttransfer&#125;::%&#123;time_total&#125;::%&#123;speed_download&#125;&quot;\n&quot; &quot;http://www.taobao.com&quot; 0.014::0.015::0.018::0.019::1516256.00 -s：去掉所有状态 -w：按照后面的格式写出rttime_namelookup：DNS 解析域名[www.taobao.com]的时间 time_commect：client和server端建立TCP 连接的时间time_starttransfer：从client发出请求；到web的server 响应第一个字节的时间time_total：client发出请求；到web的server发送会所有的相应数据的时间speed_download：下载速度 单位 byte/s0.014: DNS 服务器解析www.taobao.com 的时间单位是s0.015: client发出请求到server建立TCP的时间，里面包括DNS解析的时间 0.018: client发出请求到server响应发出第一个字节开始的时间，包括前面的2个时间 0.019: client发出请求到server把响应的数据全部发送给client,并关闭connect的时间 1516256.00 ：下载数据的速度 1. 建立TCP连接到server返回client第一个字节的时间：0.018s - 0.015s = 0.003s 2. server把响应数据发送给client的时间：0.019s - 0.018 = 0.01s]]></content>
    </entry>

    
  
  
</search>
